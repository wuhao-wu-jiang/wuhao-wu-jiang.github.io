<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="WOW">
<meta property="og:url" content="http://example.com/page/20/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>WOW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WOW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你生之前悠悠千載已逝<br>未來還會有千年沉寂的期待</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/02/QuakeHeap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/02/QuakeHeap/" class="post-title-link" itemprop="url">Quake Heap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-02 19:23:49" itemprop="dateCreated datePublished" datetime="2020-04-02T19:23:49+11:00">2020-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 10:57:54" itemprop="dateModified" datetime="2020-05-05T10:57:54+10:00">2020-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Quake Heap [1] is a min heap (or max heap) that supports the following operations:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Amortized Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>insert(x)</td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>decrease-key(x,k)</td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>delete-min()</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
</tbody>
</table>
<p>with <span class="math inline">\(O(n)\)</span> space. For comparison based min heap, either <span class="math inline">\(insert(x)\)</span> or delete-min() takes <span class="math inline">\(O(\log n)\)</span> amortized time. Otherwise, we would have an <span class="math inline">\(o(n \log n)\)</span> comparison based sorting algorithm.</p>
<p>In this blog we walk through its construction step by step and illustrate the philosophy behind. Some of the ideas also appear in other designs of min heaps.</p>
<h3 id="insertion">Insertion</h3>
<p>For insertion we are going to be lazy. Consider inserting the elements 1, 2, 3, 4, 5 into the heap. For each insertion, we just create a singleton node while maintaining a pointer (the "min-pointer") to the minimum node. The picture below shows the heap we obtain after five insertions. Each insertion has time complexity <span class="math inline">\(O(1)\)</span>.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/Insertion.jpg" /></p>
<h3 id="deletion-and-binomial-heap">Deletion and Binomial Heap</h3>
<p>It would be easier to consider the case delete-min() without decrease-key(x) first. Now we try to delete the minimum element from heap. The first step, of course, is to remove the element <span class="math inline">\(1\)</span>, after which we get the following heap.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1.jpg" /></p>
<p>Here comes the problem. The "min-pointer" is removed along with the deletion. To maintain it, it seems that we need to loop over the entire list to update the min, which takes <span class="math inline">\(O(n)\)</span> time. If we do nothing else than merely scanning all elements, we need another <span class="math inline">\(O(n)\)</span>-scanning for the next deletion. We hope that the comparison performed for the current delete-min operation can reduce the ones we need to perform in the future.</p>
<p>The idea is to merge the elements into trees. <!-- Initially, we view each element as a tree with a single node. Recursively, if the root of tree $A$ is compared with and is less than the root of tree $B$, we make $A$ as a subtree of $B$.  --> Intuitively, the trees "remember" the comparison performed before and save us from comparing the same pairs again.</p>
<p>Various tree structure can be used to record the comparison and this may result in the design of different data structure. The one picked by Quake heap is the tournament tree. It only compares and merges (linking) two trees of the same height. A new node is created as the root of the two trees. The new node's value equals to the smaller one of the roots of the two trees.</p>
<p>For example, in the following example, both the node 4 and 5 are viewed as trees with height one. We can compare and link the two trees. A new node with value 4 (the smaller value between 4 and 5) is created as the new root of the merged tree.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2.jpg" /></p>
<p>We can continue to link node 3 and 2.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3.jpg" /></p>
<p>The linking is performed recursively. Noting the the current two trees have the same height, we link them. We need to also update the "min-pointer" during the linking.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4.jpg" /></p>
<p>The construction takes <span class="math inline">\(O(n)\)</span> time. But we can charge the cost of these link operations into the creation of the trees' roots before. We have performed 3 link operations for the four nodes each being the root of a singleton tree. On average, we pay <span class="math inline">\(O(1)\)</span> per operation. To make the amortized argument more vivid, we can think that conceptually we an additional coin for each singleton tree creation. Therefore, before linking, we have four coins as follows:</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1-Coin.jpg" /></p>
<p>Merging node 5 and 4 has actual cost <span class="math inline">\(O(1)\)</span> and creates a new tree root. We use the coin of node 5 to pay the actual cost. Element 4 is the new root and it still has a coin. By using the coin idea, we charge (or averaging) the cost of this link operation to the cost of the creation of node 5.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2-Coin.jpg" /></p>
<p>Merging node 3 and 2 uses one coin. We use the coin reserved by node 3. After this, the elements 4 and 2 (the elements that are roots of some trees) still have a coin.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3-Coin.jpg" /></p>
<p>Merging the two trees left uses one coin. We use the coin reserved by node 4. After this, the element 2 is still a root and still has a coin.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4-Coin.jpg" /></p>
<p>In general, we may need to pay more than <span class="math inline">\(O(1)\)</span> for delete-min(). Consider we would like to perform the operation for the following.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-5-Coin.jpg" /></p>
<p>We need to remove all nodes on a root-to-leaf path. In this example it is the path that contains element 2.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-6-Coin.jpg" /></p>
<p>After the removal, some children of the nodes in this root-to-leaf path are now exposed as tree roots. In this example, node 4 and 3 are tree roots. We need to reserve two coins node 4 and 3. The coins are reserved for potential linking performed in the future.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-7-Coin.jpg" /></p>
<p>Finally we need to compare and link any two trees of the same height, in a recursive manner. This part is paid by the coins reserved for the tree roots.</p>
<p>To analyze the amortized running time of delete-min(), we define the height of the tree as <span class="math inline">\(H\)</span>. We need to remove <span class="math inline">\(H\)</span> nodes from the root-to-leaf path, expose <span class="math inline">\(\max \{H - 1, 0 \}\)</span> node as tree roots and reserve coins for them, followed by recursively linking two trees with the same height. The final step is "free" and covered by the coins reserved. Therefore the amortized cost is <span class="math inline">\(H + \max \{H - 1, 0\} = \max \{ 2H - 1, H \} \le 2H\)</span>.</p>
<p><em>Key Observation:</em></p>
<blockquote>
<p><strong><em>To bound the time of delete-min() to <span class="math inline">\(O(\log n)\)</span>, it is critical to control the size of <span class="math inline">\(H\)</span>.</em></strong></p>
</blockquote>
<p>To analyze how large <span class="math inline">\(H\)</span> could be, we study how it grow. Initially, a tree with <span class="math inline">\(H = 1\)</span> contains only 1 key. When we link two trees with <span class="math inline">\(H = 1\)</span>, the new tree has height <span class="math inline">\(H = 2\)</span> and <span class="math inline">\(2\)</span> keys (although it has <span class="math inline">\(3\)</span> nodes). In general, a tree with height <span class="math inline">\(H = h\)</span> contains <span class="math inline">\(2^{h - 1}\)</span> keys and this can be easily proved by induction.</p>
<blockquote>
<p>If there is no decrease-key operation, the tree with height <span class="math inline">\(h\)</span> has <span class="math inline">\(2^{h - 1}\)</span> keys and <span class="math inline">\(2^h - 1\)</span> nodes. As there are at most <span class="math inline">\(n\)</span> keys, the maximum possible height, denoted as <span class="math inline">\(H\)</span>, is bounded by <span class="math inline">\(\log n\)</span>.</p>
</blockquote>
<p>The heap we have constructed so far has a special name called "Binomial Heap".</p>
<h3 id="decrease-key">Decrease-Key</h3>
<p>If there is only insert() and decrease-key() operation, min heap is easy to implemented. We can use a linked list / dynamic array, while maintaining the min pointer / min index.</p>
<p>If we need to incorporate delete-min() operation, the decrease-key(x) itself is still easy, while the former requires significant modification. For decrease-key(x), we adopt a lazy strategy. If after decreasing, <span class="math inline">\(x\)</span>'s value is still smaller than its parent (or <span class="math inline">\(x\)</span> is the root of the tree and has no parent), then everything is fine. For example, if we decrease <span class="math inline">\(4\)</span> to <span class="math inline">\(3.5\)</span> (the node 4 has parent 2), then we do not need to modify the tree after the operation.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-1.jpg" alt="drawing" width="330" /></p>
<p>On the other hand, if we decrease 4 to 1, then its value is smaller than its parent 2.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg" /></p>
<p>We need to detach the highest node containing value 4 from its parent node (in the meanwhile we maintain the "min-pointer").</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg" /></p>
<p>The only concern with this operation is the height of a heap. In the previous, the tree on the right hand side has height <span class="math inline">\(3\)</span> but contains only two keys. For a tree with <span class="math inline">\(n\)</span> keys, it could happens that it height is <span class="math inline">\(\omega(\log n)\)</span>. Indeed, it could be as large as <span class="math inline">\(O(n)\)</span>. This will invalidate the strategy we propose in the last section, which requires the height to be <span class="math inline">\(O(\log n)\)</span>, to achieve the <span class="math inline">\(O(\log n)\)</span> amortized complexity for delete-min().</p>
<p>There are various ways to fix this, the idea of which will give rise to Pairing heap [<em>Pairing heap achieve <span class="math inline">\(O(\log n)\)</span> amortized bound for deletion but requires <span class="math inline">\(O(\log n)\)</span> amortized time for both insertion and decrease-key(x). Its design philosophy is closely related to Splay tree.</em>], Fibonacci heap, etc. Here we discuss about the solution of Quake heap.</p>
<p>First, Quake heap records the number of nodes at each height explicitly, denoted as <span class="math inline">\(n_1, n_2, ..., n_H\)</span>, where <span class="math inline">\(H\)</span> is the maximum possible height. Further, it specifies a parameter <span class="math inline">\(\alpha \in (0, 5, 1)\)</span> and maintains the invariant that <span class="math inline">\(n_{i + 1} \le \alpha \cdot n_i\)</span> for each <span class="math inline">\(i \ge 1\)</span>. This guarantees that <span class="math inline">\(H = O(\log n)\)</span>.</p>
<p>In the following discussion, we take <span class="math inline">\(\alpha = 0.75\)</span>.</p>
<p>Let's discuss how the maintain the invariant <span class="math inline">\(n_{i + 1} \le \alpha n_i\)</span> for all <span class="math inline">\(i \ge 1\)</span> for insert(x), decrease-key(x) and delete-min() operation.</p>
<ol type="1">
<li><p>For the operation insert(x), it create a singleton node at the bottom layer and increases <span class="math inline">\(n_1\)</span> by 1. If the invariant holds before insertion, it holds afterward.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeight.jpg" /></p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeightAndInsertion.jpg" /></p></li>
<li><p>For decrease, it will not change the number of nodes at each height. The following example shows the case where the children whose key is decreased is detached from its parent. <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg" /></p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg" /></p></li>
<li><p>Delete-min is the most difficult part. To maintain the invariant, now delete-min() consists of four part:</p>
<ul>
<li>Delete the min key (and all nodes that contain the min key). As before, this step may expose some children of the deleted nodes as new tree roots.</li>
<li>Recursively link all trees of the same height. After linking, scan all trees to maintain the min pointer.</li>
<li>Quake: if there is a level <span class="math inline">\(i\)</span> such that <span class="math inline">\(n_{i + 1} &gt; \alpha n_i\)</span>, remove all nodes with level greater than <span class="math inline">\(i\)</span>.</li>
</ul></li>
</ol>
<p>It is left to analyze the running time step by step. We use a potential function for analysis. By previous section, the potential should contain the number of trees. Further, by the last step of delete-min operation, it is suggested to includes the number of nodes in the potential function, to cover the cost of node removal. Inspired by this, our first design is given by <span class="math display">\[
\Phi = \# \text{nodes} + 2 \cdot \# \text{trees}
\]</span></p>
<p>We analyze the time for each step of delete-min()</p>
<ol type="1">
<li><p>Before delete-min(), the invariant holds and therefore the maximum height <span class="math inline">\(H = O(\log n)\)</span>. Deleting the min-key and its associated nodes take actual time <span class="math inline">\(O(\log n)\)</span>. As for <span class="math inline">\(\Phi\)</span>, the number of nodes decreases (indeed, this decrease will cover the removal of the nodes containing the min key) and the number of trees increases by at most <span class="math inline">\(O(\log n)\)</span>. Therefore, the amortized cost for the first step is <span class="math inline">\(O(\log n)\)</span>.</p></li>
<li><p>Linking two trees of the same height has actual cost <span class="math inline">\(1\)</span>. It creates a new node and decreases the number of trees by 1. Therefore, <span class="math inline">\(\Delta \Phi = -1\)</span>. Hence the amortized cost is 0. This also explains why we need an coefficient 2 associated with #trees in the potential function. It is left to analyze the cost of scanning all tree. After linking, all trees are of different height. It suffices to show that the maximum height is <span class="math inline">\(O(\log n)\)</span> to bound the scanning cost to <span class="math inline">\(O(\log n)\)</span>. Before linking <span class="math inline">\(H = O(\log n)\)</span>. As there are only <span class="math inline">\(n\)</span> keys, there are at most <span class="math inline">\(n\)</span> trees with height <span class="math inline">\(H\)</span> before and during the linking procedure. Linking <span class="math inline">\(n\)</span> trees of the same height results in a new tree with height <span class="math inline">\(\log n\)</span>. Therefore, after linking, <span class="math inline">\(H\)</span> increases by at most <span class="math inline">\(\log n\)</span> and <span class="math inline">\(H = O(\log n)\)</span> still holds. Therefore, the amortized cost for the second step is <span class="math inline">\(O(\log n)\)</span>.</p></li>
<li><p>Suppose in this step we delete <span class="math inline">\(k\)</span> nodes. The actual cost is <span class="math inline">\(k\)</span>. However, the number of nodes decreases by <span class="math inline">\(k\)</span>. It seems that the amortized cost is 0 for this step. But it isn't. We have increased the number of tree. Denote <span class="math inline">\(d_{i + 1}\)</span> the number of nodes at level <span class="math inline">\(i + 1\)</span> with two children before removal and <span class="math inline">\(s_{i + 1}\)</span> the number of nodes with only one children. We have <span class="math inline">\(n_{i + 1} = d_{i + 1} + s_{i + 1}\)</span>. On the other hand, we know <span class="math inline">\(n_i \ge 2 d_{i + 1} + s_{i + 1}\)</span>. By the fact that <span class="math inline">\(n_{i + 1} &gt; \alpha n_i\)</span>, we know that <span class="math display">\[
 \begin{aligned}
 s_{i + 1} 
     &amp;= 2(d_{i + 1} + s_{i + 1}) - (2 d_{i + 1} + s_{i + 1})\\
     &amp;\ge 2 n_{i + 1} - n_i \\
     &amp;\ge (2 \alpha - 1) n_i 
 \end{aligned}
 \]</span></p>
<p>as we create at most <span class="math inline">\(n_i\)</span> new trees, we can charge the creation of new trees into <span class="math inline">\(s_{i + 1}\)</span> and modify the potential as <span class="math display">\[
 \Phi = \# \text{nodes} + 2 \cdot \# \text{trees} + \frac{2}{2\alpha - 1} \# \text{nodes with one child}
 \]</span></p>
<p>Now step 3 has amortized cost 0. For other steps, this modification will increase the cost of decrease-key(x) by at most <span class="math inline">\(O(1)\)</span>.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-1.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-2.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-3.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-4.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-5.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-6.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-7.jpg" /></p></li>
</ol>
<p>Caveat: we can't swap the order of step 2 and step 3, since linking tree may create violation to the invariant and we need step 3 to fix this.</p>
<h3 id="reference">Reference</h3>
<p>[1] Chan, Timothy M. "Quake heaps: a simple alternative to Fibonacci heaps." In Space-Efficient Data Structures, Streams, and Algorithms, pp. 27-32. Springer, Berlin, Heidelberg, 2013.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/01/Ball%20and%20Bins/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/Ball%20and%20Bins/" class="post-title-link" itemprop="url">Ball and Bins</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-01 10:24:00" itemprop="dateCreated datePublished" datetime="2020-04-01T10:24:00+11:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-22 10:58:53" itemprop="dateModified" datetime="2021-03-22T10:58:53+11:00">2021-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Suppose we would like to throw <span class="math inline">\(n\)</span> balls into <span class="math inline">\(n\)</span> bins uniformly at random. We claim that the bin with maximum load has <span class="math inline">\(\Theta( \frac{\ln n}{\ln \ln n})\)</span> ball with high probability.</p>
<h1 id="upper-bound">Upper Bound</h1>
<p>The probability that a particular bin gets <span class="math inline">\(k\)</span> balls is given by</p>
<p><span class="math display">\[
\binom{n}{k}\frac{1}{n^k} \left( 1 - \frac{1}{n} \right)^{n - k} \le \binom{n}{k}\frac{1}{n^k} \le \frac{1}{k!} \le \frac{  e^k }{ k^k}
\]</span></p>
<p>where the last inequality comes from <span class="math inline">\(e^{ k } \ge \frac{k^k}{k!}\)</span>, as for <span class="math inline">\(\forall x \ge 0\)</span>, <span class="math display">\[
    e^x = 1 + x + \frac{x^2}{2!} + ...\ge \frac{x^k}{ k! }. 
\]</span></p>
<p>We want to find an <span class="math inline">\(k\)</span>, such that <span class="math display">\[
    \left( \frac{e}{ k} \right)^k = \frac{1}{n^3}.
\]</span> Taking <span class="math inline">\(\log\)</span> of both side, <span class="math display">\[
    k \ln k - k = 3 \ln n \implies k \ln k = \Theta( \ln n) \implies \ln k = \Theta( \ln \ln n). 
\]</span> Substituting <span class="math inline">\(\ln k = \Theta( \ln \ln n)\)</span> into <span class="math inline">\(k \ln k = \Theta( \ln n)\)</span>, we get <span class="math display">\[
    k  = \Theta\left( \frac{\ln n}{\ln \ln n} \right).
\]</span></p>
<p>Finally, when <span class="math inline">\(k \ge 3\)</span>, we have <span class="math display">\[
    \frac{e^k}{k^k} \ge \frac{e^{k + 1} }{ k^{k + 1} } \ge \frac{ e^{k + 1} }{ { (k + 1) }^{k + 1} }. 
\]</span></p>
<p>Hence, the probability that a particular bin receives <span class="math inline">\(k&#39; \ge k\)</span> balls is also bounded by <span class="math inline">\(e^k / k^k = 1 / n^3\)</span>.</p>
<ol type="1">
<li>By union bound over possible values of <span class="math inline">\(k&#39;\)</span>, the probability that this bin receives <span class="math inline">\(\ge k\)</span> balls is bounded by <span class="math inline">\(1 / n^2\)</span>.</li>
<li>Then by union bound over the number of possible bins, the probability that there is a bin which receives <span class="math inline">\(\ge k\)</span> ball is bounded by <span class="math inline">\(1 / n\)</span>.</li>
</ol>
<h1 id="lower-bound">Lower Bound</h1>
<p>For <span class="math inline">\(2 \le n \in \mathbb{N}^+\)</span>, by AM-GM inequality, we have <span class="math display">\[
    \sqrt[^n]{ 1 \cdot \left(\frac{n}{n - 1}\right)^{n - 1} } \le \frac{1 + (n - 1) \cdot \frac{n }{n - 1} }{ n } = \frac{1 + n}{n }. 
\]</span></p>
<p>Hence, <span class="math display">\[
    \left( 1 - \frac{1}{n} \right)^{n - 1} = \left( \frac{n - 1}{n} \right)^{n - 1} \ge \left( \frac{n }{n + 1} \right)^{n } = \left( 1 - \frac{1 }{n + 1} \right)^{n }. 
\]</span></p>
<p>Therefore, the probability that a bin gets <span class="math inline">\(k\)</span> balls is given by (for <span class="math inline">\(k \ge 1\)</span>)</p>
<p><span class="math display">\[
\begin{aligned}    
    \binom{n}{k}\frac{1}{n^k} \left( 1 - \frac{1}{n} \right)^{n - k} 
        &amp;\ge \left( \frac{n}{k} \right)^k \frac{1}{n^k} \left( 1 - \frac{1}{n} \right)^{n - 1} \\
        &amp;\ge \frac{1}{k^k} \frac{1}{e}. 
\end{aligned}
\]</span></p>
<p>If we set <span class="math inline">\(k = \frac{1}{3} \frac{ \ln n }{ \ln \ln n }\)</span>, then <span class="math display">\[
k^k \le ( \ln n)^k = n^{1/3} 
\]</span></p>
<p>Hence, <span class="math display">\[
\frac{1}{k^k} \frac{1}{e} \ge e^{ - 1} n^{-1 / 3}
\]</span></p>
<p>This probability is rather smaller. At this point it seems that a single bin is unlikely to success. But by linearity of expectation, the expected number of bins with <span class="math inline">\(k\)</span> balls is given by <span class="math inline">\(e^{ - 1} n^{ 2/ 3}\)</span>. In particular, define the indicator variables <span class="math inline">\(X_i\)</span> such that <span class="math inline">\(X_i = 1\)</span> if the <span class="math inline">\(i\)</span>-th bin receives <span class="math inline">\(k\)</span> balls and let <span class="math inline">\(X = \sum X_i\)</span> be the number of bins with <span class="math inline">\(k\)</span> balls. Then</p>
<ol type="1">
<li><span class="math inline">\(\mathbb{E}[X_i] = \Pr[X_i = 1] \ge e^{-1} n^{ - 1 / 3}\)</span>.</li>
<li><span class="math inline">\(\mathbb{E}[X] = \sum \mathbb{E}[X_i] \ge e^{ - 1} n^{ 2/ 3}\)</span>.</li>
</ol>
<p>As in expectation there are <span class="math inline">\(e^{-1} n^{2/ 3}\)</span> such bins, it seems that we are likely to find one. To formalize the intuition, we need to make sure that <span class="math inline">\(X\)</span> does not deviate from its expectation much. To see why this might cause a problem, consider the random variable <span class="math inline">\(Y\)</span> such that <span class="math display">\[
\begin{aligned}
    &amp;\Pr[Y = e^{-1} n^{ 5 / 3} ] = \frac{1}{n}, \\ 
    &amp;\Pr[Y = 0 ] = 1 - \frac{1}{n}. \\ 
\end{aligned}
\]</span></p>
<p>It has expectation <span class="math inline">\(\mathbb{E}[Y] = e^{ - 1} n^{ 2 / 3}\)</span>. But it is very likely that <span class="math inline">\(Y = 0\)</span>.</p>
<p>We investigate the variance of <span class="math inline">\(X\)</span>: <span class="math display">\[
\begin{aligned}
\mathbb{Var}[X] 
    &amp;= \sum_i \mathbb{Var}[X_i] + \sum_{i \neq j} \mathbb{Cor}(X_i, X_j) \\
    &amp;\le    \sum_i \mathbb{Var}[X_i] \\
    &amp;\le    \sum_i \mathbb{E}[X_i^2] \\
    &amp;=      \sum_i \mathbb{E}[X_i] \\
    &amp;\le    n
\end{aligned}
\]</span></p>
<p>The first inequality follows from</p>
<blockquote>
<p>Fact 1: For <span class="math inline">\(i \neq j\)</span>, <span class="math inline">\(\mathbb{Cor}(X_i, X_j) &lt; 0\)</span></p>
</blockquote>
<p>Intuitively, that bin <span class="math inline">\(i\)</span> obtains ball makes it more difficult for bin <span class="math inline">\(j\)</span> to obtain ball.</p>
<p><strong><em>Question to ponder: prove it rigorously.</em></strong></p>
<p>Finally, by Chebyshev Inequality, we have <span class="math display">\[
\Pr[ |X - \mathbb{E}[X]| \ge \mathbb{E}[X] ] \le \frac{ \mathbb{Var}[X] }{ \mathbb{E}[X]^2} \le \frac{n}{ e^{-2} n^{4  / 3}} = \frac{e^2}{n^ {1 / 3} }
\]</span></p>
<h1 id="appendix">Appendix</h1>
<p>In the appendix we discuss a rough approximation of <span class="math inline">\(k^k\)</span> for some <span class="math inline">\(k \in \mathcal{Z}_+\)</span>. We claim that <span class="math display">\[
e \cdot \frac{k^k}{e^k} \le k! \le e \sqrt k \cdot \frac{k^k}{e^k}
\]</span></p>
<p>As (<span class="math inline">\(\ln\)</span> here is based on <span class="math inline">\(e\)</span>) <span class="math display">\[
\int_{x = 1}^k \ln x \ dx = x \ln x |_{x = 1}^k - \int_{x = 1}^k x \ d \ln x = k \ln k - (k - 1)
\]</span></p>
<p>We get <span class="math display">\[
\ln k! = \sum_{i = 1}^k \ln i \ge \int_{x = 1}^k \ln x \ dx  = k \ln k - (k - 1)
\]</span></p>
<p>Similarly,</p>
<p><span class="math display">\[
\begin{aligned}
\ln k! 
&amp;= \sum_{i = 1}^k \ln i \\
&amp;= \frac{1}{2} \sum_{i = 1}^{k - 1} [\ln i + \ln (i + 1) ] + \frac{1}{2} \ln k \\
&amp; \le  \int_{x = 1}^k \ln x \ dx + \frac{1}{2} \ln k \\
&amp;= (k + \frac{1}{2}) \ln k - (k - 1)
\end{aligned}
\]</span></p>
<h1 id="reference">Reference:</h1>
<ol type="1">
<li>Sanjeev Arora, Cos 521: Advanced Algorithm Design, Lecture 1: Course Intro and Hashing</li>
<li>Sariel Har-Peled, Chapter 4, The Occupancy and Coupon Collector problems.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/31/Sampling-With-Or-Without-Replacement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/31/Sampling-With-Or-Without-Replacement/" class="post-title-link" itemprop="url">Sampling With Or Without Replacement</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-31 22:58:36 / Modified: 23:59:13" itemprop="dateCreated datePublished" datetime="2020-03-31T22:58:36+11:00">2020-03-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Suppose that there are <span class="math inline">\(a\)</span> blue balls and <span class="math inline">\(b\)</span> red balls in a box and we would like to sample <span class="math inline">\(k\)</span> balls from them. We can sample the balls with replacement such that after picking each ball we put it back into the box, or we can do it without replacement.</p>
<p>For convenience of discussion, denote <span class="math inline">\(n = a + b\)</span>, <span class="math inline">\(p = \frac{a}{n}\)</span> and <span class="math inline">\(q = \frac{b}{n}\)</span>. Define <span class="math inline">\(X_i\)</span> (<span class="math inline">\(i \in [k]\)</span>) the indicator random variable of whether the <span class="math inline">\(i\)</span>-th selected ball is blue. Let <span class="math display">\[
X = \sum X_i
\]</span></p>
<p>Then we claim that <span class="math display">\[
E[X] = \sum_{i \in [k]} E[X_i] = kp
\]</span></p>
<p>The first equality holds by linearity of expectation. The second equality states that in expectation, <span class="math inline">\(p\)</span> fraction of the selected balls are blue.</p>
<p>The claim is trivial when we sample with replacement, as <span class="math inline">\(\Pr[X_i = 1] = p\)</span>. To prove that the probability applies for the case of sampling without replacement requires a little more effort, as shown by the following</p>
<ol type="1">
<li>There are in total <span class="math inline">\(\begin{pmatrix} n \\ k\end{pmatrix}\)</span> possible combinations of choosing <span class="math inline">\(k\)</span> balls out of <span class="math inline">\(n\)</span>.</li>
<li>Among them there are <span class="math inline">\(\begin{pmatrix} a \\ 1 \end{pmatrix} \cdot \begin{pmatrix} n - 1 \\ k - 1 \end{pmatrix}\)</span> combinations such that the <span class="math inline">\(i\)</span>-th ball is blue.</li>
<li>Therefore, <span class="math inline">\(\Pr[X_i = 1] = \frac{ \begin{pmatrix} a \\ 1 \end{pmatrix} \cdot \begin{pmatrix} n - 1 \\ k - 1 \end{pmatrix} }{ \begin{pmatrix} n \\ k\end{pmatrix} } = \frac{a}{n} = p\)</span>.</li>
</ol>
<p>However, the two sampling scheme have different variance.</p>
<h5 id="variance-of-sampling-with-replacement">Variance of Sampling With Replacement</h5>
<p>By independence of <span class="math inline">\(X_i\)</span> <span class="math display">\[
Var[X] \doteq \sigma^2 = \sum_{i \in [k]} Var[X_i] = k p q
\]</span></p>
<h5 id="variance-of-sampling-without-replacement">Variance of Sampling Without Replacement</h5>
<p>In this case, the <span class="math inline">\(X_i\)</span>'s are not independent. <span class="math display">\[
\begin{aligned}
       Var[X]  
        &amp;= E \left[ X^2 \right] - \left( E[X] \right)^2 \\
        &amp;= \sum_{i \in [k]} E[X_i^2] + \sum_{i, j \in [k]} E[X_i X_j] - (kp)^2 \\
        &amp;=  kp + k(k - 1) \frac{ \begin{pmatrix} a \\ 2 \end{pmatrix} \cdot \begin{pmatrix} n  - 2 \\ k - 2 \end{pmatrix} }{ \begin{pmatrix} n \\ k\end{pmatrix} } - (kp)^2 \\
        &amp;=  kp + k(k - 1) \frac{ a(a-1) }{ n(n - 1) } - (kp)^2 \\
        &amp;=  kp + kp \frac{ (k - 1) (a-1) }{ (n - 1) } - (kp)^2 \\
        &amp;=  kp ( 1 + \frac{ (k - 1) (a-1) }{ (n - 1) } - k \frac{a}{ n } ) \\
        &amp;=  kp \frac{n^2 - n + ka n - kn - an + n - kan + ka }{ n (n - 1) } \\
        &amp;=  kp \frac{n^2  - kn - an  + ka }{ n(n - 1) } \\
        &amp;=  kp \frac{(n - a) (n - k)}{ n (n - 1)} \\
        &amp;=  kpq \frac{n - k}{n - 1} \\
        &amp;= \sigma^2 \frac{n - k}{n - 1}
\end{aligned}
\]</span></p>
<p>We have shown that sampling without replacement has smaller variance than sampling with replacement. Moreover, if <span class="math inline">\(n \succ k\)</span>, then <span class="math inline">\(\frac{n - k}{n - 1} \approx 1\)</span> and the two sampling scheme have almost the same variance. We can bound the concentration behavior of <span class="math inline">\(X\)</span> by Chebyshev's inequality: for any <span class="math inline">\(c &gt; 0\)</span>, <span class="math display">\[
\Pr[ |X - E[X] | \ge c \cdot \sigma] \le \frac{Var[X] }{c^2 \sigma^2} = \frac{1}{c^2}
\]</span></p>
<p>The <span class="math inline">\(3\)</span>-sigma rule says only <span class="math inline">\(X\)</span> deviates more than <span class="math inline">\(3\sigma\)</span> from its expectation with probability at most <span class="math inline">\(11.11\%\)</span> <span class="math display">\[
\Pr[ |X - E[X] | \ge 3 \cdot \sigma] \le \frac{Var[X] }{c^2 \sigma^2} = \frac{1}{9} \approx 0.1111
\]</span></p>
<p>It is also interesting to observe that the variance most related to the sample size <span class="math inline">\(k\)</span> and probabilities <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> , but not <span class="math inline">\(n\)</span>!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/50/">50</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WOW</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
