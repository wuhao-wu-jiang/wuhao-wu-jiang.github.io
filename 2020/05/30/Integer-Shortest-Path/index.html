<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Single source shortest path is one of most popular the topics taught in a introductory algorithm course. Given a graph $G &#x3D; \left&lt; V, E \right&gt;$ with $n$ vertices and $m$ edges, the famous Dijks">
<meta property="og:type" content="article">
<meta property="og:title" content="Integer Shortest Path">
<meta property="og:url" content="http://example.com/2020/05/30/Integer-Shortest-Path/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:description" content="Single source shortest path is one of most popular the topics taught in a introductory algorithm course. Given a graph $G &#x3D; \left&lt; V, E \right&gt;$ with $n$ vertices and $m$ edges, the famous Dijks">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/1.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/2.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/3.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/4.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/5.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example1-2.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example3.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example4.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example5.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example6.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example7.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example8.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example9.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example10.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Drawback.png">
<meta property="article:published_time" content="2020-05-30T01:15:49.000Z">
<meta property="article:modified_time" content="2020-06-18T03:01:58.088Z">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/1.png">

<link rel="canonical" href="http://example.com/2020/05/30/Integer-Shortest-Path/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Integer Shortest Path | WOW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WOW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/30/Integer-Shortest-Path/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="你生之前悠悠千載已逝，未來還會有千年沉寂的期待">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Integer Shortest Path
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-30 11:15:49" itemprop="dateCreated datePublished" datetime="2020-05-30T11:15:49+10:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-18 13:01:58" itemprop="dateModified" datetime="2020-06-18T13:01:58+10:00">2020-06-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Single source shortest path is one of most popular the topics taught in a introductory algorithm course. Given a graph $G = \left&lt; V, E \right&gt;$ with $n$ vertices and $m$ edges, the famous Dijkstra’s algorithm has runtime $O(m \log n)$ by using a binary heap. When more advanced heap such such Fibonacci heap is deployed, the runtime can be improved to $O(m + n \log n)$. Most introductory courses are satisfied with the above solutions without going further. </p>
<p>Here we explore the topic by considering a special case where all edge weights are non-negative integers within the set ${0, 1, 2, …, C}$. We develop new heaps incrementally and we will finally see that Dijkstra algorithm can do substantially better than $O(m + n \log n)$. </p>
<h4 id="Time-O-m-nC-Space-O-nC"><a href="#Time-O-m-nC-Space-O-nC" class="headerlink" title="Time: $O(m + nC)$, Space: $O(nC)$."></a>Time: $O(m + nC)$, Space: $O(nC)$.</h4><p>As a warm up, we demonstrate an algorithm with runtime $O(m + nC)$ and space overhead $O(nC)$. Here we exclude the space $O(m + n)$ required for storing the graph to simplify the discussion and comparison between the algorithms. </p>
<p>The idea is very simple. We know that the possible distance from any vertex to the source vertex (denoted as $s$) is no less than $nC$. It suffices to keep an array $A_1$ with length $nC$, such that $A_1[i]$ maintains the set of vertices with temporary distance $i$. In this context, we call $A_1[i]$ a bucket and the array $A_1$ itself the buckets.  </p>
<p>Initially all $A_1[i]$’s are empty except that $A_1[0]$ contains the source vertex. The algorithm iterates over $A_1$ to find an unmarked vertex with the minimum distance, marked it, update its neighbors’ distances and move them to the corresponding buckets. </p>
<p>Each vertex is inserted into $A_1$ once. There are at most $m$ updates of vertices’ distances. As the minimum distance of the unmarked vertices is monotonically increasing, we scan the array $A_1$ only once. Summing over the cost we get the $O(m + nC)$ time complexity bound. </p>
<h4 id="Time-O-m-nC-Space-O-C"><a href="#Time-O-m-nC-Space-O-C" class="headerlink" title="Time: $O(m + nC)$, Space: $O(C)$."></a>Time: $O(m + nC)$, Space: $O(C)$.</h4><p>The space usage of the above algorithm can be improve to $O(C)$. Relabel the vertices as $s = v_0, v_1, v_2, …, v_n$ according to the order they are marked. </p>
<p>Suppose that Dijkstra’s algorithm uses an array $d$ to record the vertices’ distances to $s$. Initially, $d(s) = 0$ and $d(v) = \infty$ for $\forall v \neq s$. Now, consider the moment that $k$ ($0 \le k &lt; n$) vertices have been marked. For $i &gt; k$, the value of $d(v_i)$ is either </p>
<ol>
<li><p>$d(v_i) = \infty$, if $v_i$ is not adjacent to any vertex $v_j$ for $j \le k$. In this case $v_i$ is not in the array $A_1$.     </p>
</li>
<li><p>$d(v_i) = d(v_j) + w_{i,j}$ for some $j \le k$, where $w_{i,j}$ is the edge weight between $v_i$ and $v_j$.   </p>
</li>
</ol>
<p>By the property of Dijkstra’s algorithm, at this moment it also holds that<br>$$<br>0 = d(s) = d_(v_0) \le d(v_1) \le d(v_2) … \le d(v_k)<br>$$</p>
<p>Therefore, for $i &gt; k$, either $v_i$ is not in $A_1$ or<br>$$<br>d(v_i) \le d(v_j) + w_{i,j} \le d(v_k) + C<br>$$</p>
<p>All un-marked vertices that are in $A_1$ must be in the range of<br>$$<br>A_1[d(v_k) … d(v_k) + C]<br>$$</p>
<p>In general, let $\mu$ be the distance of the least marked vertex. It suffices to maintain a window of $A_1[\mu…\mu+C]$. We can implement this by initializing $A_1$ with size $C+1$ and use it in a wrap-around manner. </p>
<h4 id="Time-O-m-n-sqrt-C-Space-O-C"><a href="#Time-O-m-n-sqrt-C-Space-O-C" class="headerlink" title="Time: $O(m + n \sqrt C)$, Space: $O(C)$."></a>Time: $O(m + n \sqrt C)$, Space: $O(C)$.</h4><p>In previous section, we successfully reduce the size of $A_1$ to $1 + C$. But the runtime remains $O(m + nC)$. To motivate the algorithm discussed in this section, we first provide an alternative view of this complexity:</p>
<ol>
<li><p>We update the vertices’ distance and move the vertices between buckets, which has cost  $O(m)$;   </p>
</li>
<li><p> At each iteration of Dijkstra’s algorithm, in the worst case, we need to scan the entire array of $A_1$ to find an unmarked vertex with minimum distance, which takes $O(C)$ times. This is repeated $n$ times.  </p>
</li>
</ol>
<p>Where could we have wasted our time? Do we really have spend $O(C)$ time to find the unmarked vertex with minimum distance? </p>
<p>We can improve this to $O(\sqrt C)$ by using two-level buckets. We break the buckets in $A_1$ into $\sqrt { C + 1}$ blocks, each of size $\sqrt { C + 1}$ (assume here $\sqrt { C + 1}$ is an integer for simplicity). For each block, we use one flag bit to indicate whether this block is empty. This results in $\sqrt { C + 1}$ flags bits, which are stored in bit array $A_2$. From now on, </p>
<p> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/1.png"></p>
<p>Now, to find an unmarked vertex with minimum distance, we scan $A_2$ to find the first non-zero bit then the corresponding bucket in $A_1$,  which takes $O(\sqrt C)$ time. Totaling the runtime, we obtain a bound of $O(m + n \sqrt C)$. </p>
<p><strong><em>Question to ponder: calculate the size of $\sqrt C$ for some values of $C$ which you consider reasonable in real applications.</em></strong></p>
<h4 id="Time-O-m-log-frac-m-n-C-Space-O-C"><a href="#Time-O-m-log-frac-m-n-C-Space-O-C" class="headerlink" title="Time: $O( m \log_{ \frac{m}{n} } C)$, Space: $O(C)$."></a>Time: $O( m \log_{ \frac{m}{n} } C)$, Space: $O(C)$.</h4><p>It is natural to extend the idea to $3$-level buckets. Suppose the block size if $\Delta$. Then the third level contains a single bit block of size $\Delta$, the second level contains $\Delta$ bit blocks (with total size $\Delta^3$), and the first level contains the buckets $A_1$ of size $\Delta^3 = C + 1$. It follows that $\Delta = (C + 1)^\frac{1}{3}$ and the time complexity is $O(m + n C^\frac{1}{3} )$. </p>
<p>We may use four level buckets, in which $\Delta = (C + 1)^\frac{1}{4}$ and the time complexity is $O(m + n C^\frac{1}{4})$. </p>
<p><strong><em>Question to ponder: calculate the size of $C^\frac{1}{3}$ and $C^\frac{1}{4}$ for some values of $C$ which you consider reasonable in real applications.</em></strong></p>
<p>Does the analysis carry for $k$-level buckets for general value of $k$? No. We can no longer consider the $k$ as a constant and have to take into consider the overhead of insertion, decrease-key and deletion explicitly. </p>
<p>For a $k$-level bucket structure with bucket size $\Delta = (1 + C)^\frac{1}{k} \ge 2$, </p>
<ol>
<li><p>insertion takes $O(k)$ time,  </p>
</li>
<li><p>decrease-key takes $O(k)$ time,  </p>
</li>
</ol>
<p>as we need to maintain the indicators bits in $2…k$ levels. Finally, </p>
<ol start="3">
<li>delete-min takes $O(k \Delta)$ time,  </li>
</ol>
<p>as we need to scan $k$ buckets, each of size $\Delta$, to find the min element and delete it. </p>
<p> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/2.png"></p>
<p>The time complexity now becomes<br>$$<br>O(mk + n k \Delta) = O( mk + nkC^\frac{1}{k})<br>$$</p>
<p>Balancing the two terms, we get $\frac{1}{k} =  \frac{ \log \frac{m}{n} }{ \log C}$, i.e., $k = \log_{\frac{m}{n} } C$. To summarize, the time is<br>$$<br>O(m \log_{\frac{m}{n} } C)<br>$$</p>
<p>and the space overhead is<br>$$<br>O\left( \sum_{i = 0}^{k - 1} C / \Delta^i \right) = O(C)<br>$$</p>
<p><strong><em>Question to ponder: calculate the size of $\log_{\frac{m}{n} } C$ for some values of $C$ which you consider reasonable in real applications.</em></strong></p>
<h4 id="Time-O-m-n-frac-log-C-log-log-C-Space-O-frac-log-C-log-log-C-2"><a href="#Time-O-m-n-frac-log-C-log-log-C-Space-O-frac-log-C-log-log-C-2" class="headerlink" title="Time: $O(m + n \frac{\log C}{\log \log C})$, Space: $O( (\frac{\log C}{\log \log C} )^2  )$."></a>Time: $O(m + n \frac{\log C}{\log \log C})$, Space: $O( (\frac{\log C}{\log \log C} )^2  )$.</h4><p>The core idea underlying the k-level bucket structure discussed in the previous section is that every integer $w$ in $[0, C]$ can be written as a base-$\Delta$ number with length at most $k$:<br>$$<br>w = \sum_{i = 0}^{k - 1} w_i \cdot \Delta^i<br>$$</p>
<p>where $w_i \in [0, \Delta)$. For convenience, we write it as<br>$$<br>w = (w_{k - 1}, w_{k - 2}, …, w_0)_\Delta<br>$$</p>
<p>Now the meaning of the $k$-level buckets is clear. The $k^{th}$ level partitions the $w$’s according to the value of $w_{k - 1}$. The $(k - 1)^{th}$ level further partitions the $w$’s according to the value of $w_{k - 2}$, and so on. The path from the top level to bottom level is uniquely determined by the sequence $(w_{k - 1}, w_{k - 2}, …, w_0)_\Delta$. Indeed, this is a special case of <strong><em>trie</em></strong>, which has alphabet size $\Delta$ and contains only sequence of length $k$. </p>
<p>But we may still waste some work. Remember that our goal for designing the data structure is to find the min element. Therefore, it suffices to distinguish the min element from the rest. We should not waste our effort in determining the relative order between the non-min elements. </p>
<p>In the following example, the min elements $v_1, v_2$ fall into the subtree of the first bucket on the $k^{th}$ level while $v_{n - 1}, v_n$ fall into the last one. As $v_{n - 1}, v_n$ are not min elements, it is unnecessary to maintain a subtree to separate them. Worse still, if later decrease-key is applied to either $v_{n -1}$ or $v_n$, and if the new key has to be moved to a new bucket in the $k^{th}$ level, the effort we have spent in constructing the sub-tree is completely useless. </p>
<p>Instead, we can create an auxiliary set to the last bucket on level $k$, to pus $v_{n - 1}, v_n$ into the set directly. Similar idea apply to $v_3$ in the example. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/3.png"></p>
<p>The new structure we get is as follows:</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/4.png"></p>
<p>In general, we may not even has a $k$-level trie. In the example below, we can already determine the min-element $v_1$ at some level $i &gt; 1$. Why should we bother to expand the buckets further? Note that this idea is similar to that of trie compression used in <strong><em>Patricia trie</em></strong>. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/5.png"></p>
<p>We can be even more lazy. We expand a bucket only when it is necessary. See the example below as an example. In this example, $C = 15$ and $\Delta = 4$.  </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example1-2.png"></p>
<p>Now, to delete-min, we need to determine the order of $v_1, v_2$. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example3.png"></p>
<p>Inserting a new element follows the current structure, until it finds a bucket to fall in. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example4.png"></p>
<p>Delete-min begin the search from the lowest level non-empty bucket block.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example5.png"></p>
<p>After delete-min, we may need to delete the empty bucket blocks recursively.  For each bucket block, we maintain counter for the number of non-empty buckets. This allows us to delete empty bucket blocks in $O(k)$ time.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example6.png"></p>
<p>We decrease the key of $v_4$ to 9. Note that we do not need to compare $v_4$ and $v_5$ for the moment. Bucket block counter is maintained when $v_4$ is moved to another bucket. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example7.png"></p>
<p>Delete-min is invoked again. We need to expand the bucket containing $v_5$ and $v_4$ to distinguish them.  </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example8.png"></p>
<p>We continue to insert a new element $v_6 = 12$. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example9.png"></p>
<p>We decrease the key of $v_6$ to $10$. It is pushed down by one level.   </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Example10.png"></p>
<p>We are now prepared to analyze the amortized cost of these operations:</p>
<ol>
<li><p>Insert: we pay an $O(k)$ amortized cost of insertion. Any subsequent pushed down operation on this element is charged to its insertion. Note that an element can be push-down by at most $k$ levels. </p>
</li>
<li><p>Decrease-key: we pay an $O(1)$ amortized cost of decrease-key operation. The push-down operation is charged to its insertion.  </p>
</li>
<li><p>Delete-min: to find the min-element, we scan the bucket block in the lowest level to find the first non-empty bucket. This has time $\Delta$. If the bucket found contains multiple elements, we perform an expansion and push the elements down, the cost of which is charged to insertion of these elements. Finally, we may need to delete empty bucket blocks recursively, which has cost $O(k)$.  </p>
</li>
</ol>
<p>Therefore, the Dijkstra’s algorithm with this structure has runtime $O(m + n(k + \Delta))$, which is minimized when<br>$$<br>k = \Delta = (C + 1)^\frac{1}{k}<br>$$</p>
<p>Solving the equation gives $k = O(\frac{\log C}{\log \log C} )$. </p>
<h4 id="Time-O-m-n-sqrt-log-C-Space-O-sqrt-log-C-cdot-2-sqrt-log-C"><a href="#Time-O-m-n-sqrt-log-C-Space-O-sqrt-log-C-cdot-2-sqrt-log-C" class="headerlink" title="Time: $O( m + n \sqrt{\log C} )$, Space: $O(\sqrt{\log C} \cdot 2^{\sqrt{\log C} })$."></a>Time: $O( m + n \sqrt{\log C} )$, Space: $O(\sqrt{\log C} \cdot 2^{\sqrt{\log C} })$.</h4><p>Beginning from the naïve approach, we have improved a lot on both time and space overhead. Amazingly, this is not the end of the story. To motivate what is possibly the inefficient part of $O(m + n \frac{\log C}{\log \log C})$ approach, look at the following example. </p>
<p>Suppose that $C$ is a large number. Initially the structure is empty. We insert an element $v_1$ followed by $v_2$ and they fall into the same bucket in the $k^{th}$ level. Next, we perform a delete-min operation. To distinguish, we expand the buckets all the way down to $1^{st}$ level. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/IntegerShortestPath/Drawback.png"></p>
<p>But since there are two elements, why don’t we compare them directly and return the minimum one? In such case we avoid the unnecessary expansions. </p>
<p>We can extend the idea further. If the number of elements in a bucket is too few, we refuse to expand it. Instead we make of copy of the elements and construct a comparison based priority queue (e.g., Fibonacci heap) on them. Further, note that we are only interested in the possible min-element. Therefore the heap is constructed for only one bucket that contains the min-element.    </p>
<p>We use a parameter $t$ (to be determined) to control this number. In particular, if the number is at most $t$, we construct a comparison based priority queue. We perform expansion only if the number exceeds $t$. </p>
<ol>
<li><p>Insert: insert an element as before. If the element falls into the bucket that is associated with a priority, then also insert this element into the heap.</p>
</li>
<li><p>Decrease-key: if the element is in the bucket that is associated with a priority queue, perform decrease-key in the queue. Otherwise, perform decrease-key as before. If the element falls into the bucket that is associated with a priority queue, then also insert this element into the heap.</p>
</li>
<li><p>Delete-min: </p>
</li>
</ol>
<blockquote>
<ol>
<li>Find the first non-empty bucket in the lowest level     </li>
<li><strong><em>IF</em></strong> the bucket has more than $t$ elements <strong><em>THEN</em></strong>    </li>
<li>$\qquad$ Expand the bucket    </li>
<li>$\qquad$ <strong><em>GO TO STEP 1</em></strong> </li>
<li><strong><em>ELSE</em></strong> </li>
<li>$\qquad$ <strong><em>IF</em></strong> $\nexists$ queue <strong><em>THEN</em></strong>    </li>
<li>$\qquad\qquad$ Construct a queue</li>
<li>$\qquad$ Perform delete-min in the queue </li>
</ol>
</blockquote>
<p>Let $I(t), D(t), X(t)$ be the time needed to perform insert, decrease-key and delete-min operation in a comparison based priority queue respectively. Then it is obvious that the the structure we propose, the amortized time we need for insert and decrease-key is</p>
<ol>
<li>Insert: $O(k + I(t))$. </li>
<li>Decrease-key: $O(D(t) + I(t))$. </li>
</ol>
<p>To analyze the time needed for delete-min is more complicated. It relies on the implementation of  the following:</p>
<blockquote>
<p>Find the first non-empty bucket in the lowest level.     </p>
</blockquote>
<p>We record the previous deleted min element $\mu$ (initially set to 0).  Denote the $\Delta$-base representation of $\mu$ as<br>$$<br>\mu = (\mu_{k - 1}, \mu_{k - 2}, …, \mu_0)<em>\Delta<br>$$<br>Observe that the non-empty bucket block in the lowest level must contain $\mu$. Denote this level as $i$. To find the first non-empty bucket, we start scan from $\mu</em>{i - 1}^{th}$ bucket in the $i^{th}$ level. Therefore, each bucket block is only scanned once. Further, the buck block in the $i^{th}$ level is created from the $(i + 1)^{th}$ level because it contains more than $t$ elements. We can charge the scanned cost to these $t$ elements, each with $\frac{\Delta}{t}$. As there are $k$ level, a element could be charge at most $k$ times. It follows that the amortized cost of delete-min is given by</p>
<ol start="3">
<li>Delete-min: $O(X(t) + \frac{k \Delta}{t})$</li>
</ol>
<p>For Fibonacci heap, $I(t) = D(t) = 1$ and $X(t) = \log t$. Therefore, we have runtime<br>$$<br>O \left( m + n \left[k + \log t + \frac{k \Delta}{t} \right] \right)<br>$$</p>
<p>To minimize it, we need to set $k = \log t = \frac{k \Delta}{t}$. It holds that $t = 2^k$ and $t = \Delta = C^\frac{1}{k}$, which implies that $2^{k} = 2^{ \frac{\log C}{k} }$ and $k = \sqrt {\log C}$.  The time is<br>$$<br>O(m + n \sqrt{\log C})<br>$$</p>
<p>and the space overhead is $O(k \Delta) = O(\sqrt{\log C} \cdot 2^{\sqrt{\log C} })$. </p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1]. David R. Karger, MIT Advanced Algorithm, 2013.<br>[2]. B. V. Cherkassky, A. V. Goldberg, and C. Silverstein, “Buckets, Heaps, Lists, and Monotone Priority Queues,” SIAM J. Comput., vol. 28, no. 4, pp. 1326–1346, Jan. 1999</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/26/Splay-Tree/" rel="prev" title="Splay Tree">
      <i class="fa fa-chevron-left"></i> Splay Tree
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/01/Entropy-and-Random-Bits/" rel="next" title="Entropy and Random Bits">
      Entropy and Random Bits <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Time-O-m-nC-Space-O-nC"><span class="nav-number">1.</span> <span class="nav-text">Time: $O(m + nC)$, Space: $O(nC)$.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Time-O-m-nC-Space-O-C"><span class="nav-number">2.</span> <span class="nav-text">Time: $O(m + nC)$, Space: $O(C)$.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Time-O-m-n-sqrt-C-Space-O-C"><span class="nav-number">3.</span> <span class="nav-text">Time: $O(m + n \sqrt C)$, Space: $O(C)$.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Time-O-m-log-frac-m-n-C-Space-O-C"><span class="nav-number">4.</span> <span class="nav-text">Time: $O( m \log_{ \frac{m}{n} } C)$, Space: $O(C)$.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Time-O-m-n-frac-log-C-log-log-C-Space-O-frac-log-C-log-log-C-2"><span class="nav-number">5.</span> <span class="nav-text">Time: $O(m + n \frac{\log C}{\log \log C})$, Space: $O( (\frac{\log C}{\log \log C} )^2  )$.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Time-O-m-n-sqrt-log-C-Space-O-sqrt-log-C-cdot-2-sqrt-log-C"><span class="nav-number">6.</span> <span class="nav-text">Time: $O( m + n \sqrt{\log C} )$, Space: $O(\sqrt{\log C} \cdot 2^{\sqrt{\log C} })$.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number"></span> <span class="nav-text">Reference</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description">你生之前悠悠千載已逝，未來還會有千年沉寂的期待</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WOW</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
