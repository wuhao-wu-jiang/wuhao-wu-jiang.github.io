<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Splay Tree [1] is a self-binary search tree that achieves $O(\log n)$ amortized time complexity for each operation. Unlike other balanced binary search trees, it does not require to maintain additiona">
<meta property="og:type" content="article">
<meta property="og:title" content="Splay Tree">
<meta property="og:url" content="http://example.com/2020/05/26/Splay-Tree/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:description" content="Splay Tree [1] is a self-binary search tree that achieves $O(\log n)$ amortized time complexity for each operation. Unlike other balanced binary search trees, it does not require to maintain additiona">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/Zig.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/ZigZig.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/ZigZag.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/ZigZig.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/ZigZag.png">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/Zig.png">
<meta property="article:published_time" content="2020-05-26T06:19:41.000Z">
<meta property="article:modified_time" content="2020-06-05T06:12:56.000Z">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/Zig.png">

<link rel="canonical" href="http://example.com/2020/05/26/Splay-Tree/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Splay Tree | WOW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WOW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/26/Splay-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="你生之前悠悠千載已逝，未來還會有千年沉寂的期待">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Splay Tree
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-26 16:19:41" itemprop="dateCreated datePublished" datetime="2020-05-26T16:19:41+10:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-05 16:12:56" itemprop="dateModified" datetime="2020-06-05T16:12:56+10:00">2020-06-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Splay Tree [1] is a self-binary search tree that achieves $O(\log n)$ amortized time complexity for each operation. Unlike other balanced binary search trees, it does not require to maintain additional information to keep balance. Further, it has good property that more recently accessed nodes are more easily retrieved and achieves certain optimality even for an unknown sequence of operations.</p>
<h2 id="Basic-Operations"><a href="#Basic-Operations" class="headerlink" title="Basic Operations"></a>Basic Operations</h2><p>The philosophy of splay tree is very simple: just bring the last accessed node $x$ to the root of the tree, via a sequence of <em>rotations</em>. This brings the most recently visited nodes close to the root. </p>
<p>[Remark: For insertion, the last accessed node is the node inserted.  For a successful search operation, the last accessed node is the node found. For an unsuccessful search/deletion, it is the predecessor or successor of the search  node / deleted node. ]</p>
<p>The rotations that bring a node $x$ to the root is not unique. For example, the simplest one rotates $x$  with its parent until it becomes the root. However, we can easily find counter examples for this naïve approach. The rotations need to be carefully designed and are called <em>splays</em>.  At each step the node being splayed is brought up at most 2 levels. It can be divided into three categories. Call $x$ the node being splayed, $y$ its parent and $z$ its grandparent (if they exist).</p>
<ol>
<li>Root case: $x$ is the root. Do nothing. </li>
<li>The <em>Zig</em> case: $y$ is the root. We just perform $rotate(x, y)$.   <ul>
<li>See the following figure.<br><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/Zig.png"></li>
</ul>
</li>
<li>Otherwise, $x$ has a grandparent $z$. It is further divided into two categories: <ol>
<li><em>Zig-Zig</em> case: both $x$ and $y$ are left children or right children. We first perform $rotate(y, z)$ then $rotate(x, y)$.<br><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/ZigZig.png"></li>
<li><em>Zig-Zag</em> case: $x$ and $y$ are different children of their parents, i.e., $x$ is the left child and $y$ is the right child, or vice versa. We first perform $rotate(x, y)$ then $rotate(y, z)$.<br><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/ZigZag.png"> </li>
</ol>
</li>
</ol>
<p>The splay is performed repeatedly on $x$ until it reaches the root. It is also possible to perform equivalent operations in an top-down approach [1]. </p>
<h2 id="Time-Analysis"><a href="#Time-Analysis" class="headerlink" title="Time Analysis"></a>Time Analysis</h2><p>There is no explicit control over the height of the tree. It is possible that the accessed node has depth $\Omega(\log n)$.  The intuition is that, however, the imbalanced situation is not easy to create and must accumulate from previous operations. The number such operations can not be too to create the imbalance. We can charge the cost of accessing the node with long depth to these operations. Intuitively, each previous operation is required to reserve some additional “energy” for the amount of imbalanced it creates, which is used later to fix the imbalance. When a long path is encountered, there should be enough “energy” to cover the search on the path and the splay of the access node. </p>
<p>It is left to give a quantitative scheme for keeping the “energy” and “using” the “energy”. We need a few more definitions for a node $x$.</p>
<ol>
<li>$T(x):$ the subtree rooted at $x$. </li>
<li>$w(x):$ the weight associated with node $x$. This weight is only used for analysis and is not kept explicitly by splay tree. </li>
<li>$s(x)=\sum_{y \in T(x)} w_y:$ the sum of weights of nodes in $T(x)$, which is referred to as the size of $x$. </li>
<li>$r(x) \doteq \log r(x)$, the rank of $x$. </li>
</ol>
<p>Let $T$ be the splay tree. The potential function is defined as<br>$$<br>\Phi = \sum_{x \in T} r(x)<br>$$<br>which records the amount of “energy” in $T$. </p>
<p>The amortized cost of an operation is defined as<br>$$<br>\text{amortized cost} = \text{actual cost} + \Delta \Phi<br>$$<br>where $\Delta \Phi$ is the change of the potential function.</p>
<p>Now, let $r(x)$ be the rank of $x$ before we performed a single splay operation on $x$ and $r’(x)$ the one after. The <em>Access Lemma</em> states the $\Phi$ changes as follows:</p>
<blockquote>
<p><strong><em>Access Lemma</em></strong> For a single splay operation, the potential change is bounded by<br>$$ 3(r’(x) - r(x)) - 2 $$<br>for <em>zig-zig</em> and <em>zig-zag</em> case and<br>$$ r’(x) - r(x) $$<br>for the <em>zig</em> case.</p>
</blockquote>
<p>Before we prove this key lemma, we use it for the following theorem.</p>
<p><strong><em>Theorem.</em></strong> The amortized cost of the splaying a node $x$ to the root is $O(1 + \log \frac{s(root) }{s(x) })$. </p>
<p><em>Proof.</em>  To splay a node $x$ to the root, suppose that we have performed $k$ splays. Further, let $r_i(x)$ be the rank of $x$ after we performed the $i^{th}$ splay on $x$. We have $r_0(x) = \log s(x)$ and $r_k(x) = \log s(root)$. Observe that the actual cost of splay operation is $2$ for <em>zig-zig</em> and <em>zig-zag</em>  case and 1 for the <em>zig</em> case. Hence, the amortized cost is<br>$$<br>\begin{aligned}<br>\text{amortized cost}<br>&amp;\le \sum_{i = 1}^k 3(r_i(x) - r_{i - 1}(x)) +1 \<br>&amp;= 3(r_k(x) - r_0(x)) + 1<br>\end{aligned}<br>$$<br>The added 1 results from the final possible <em>zig</em> operation. </p>
<p>$\blacksquare$</p>
<p>If we set $w(x) = 1$ for all nodes, then $r_k(x) = \log n$ and $r_1(x) \ge \log 1 = 0$. Therefore, the amortized cost of splaying $x$ is bounded by $O(\log n)$. </p>
<h3 id="Proof-of-The-Access-Lemma"><a href="#Proof-of-The-Access-Lemma" class="headerlink" title="Proof of The Access Lemma."></a>Proof of The Access Lemma.</h3><h4 id="Zig-Zig"><a href="#Zig-Zig" class="headerlink" title="Zig-Zig"></a><strong><em>Zig-Zig</em></strong></h4><ul>
<li><p>Example.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/ZigZig.png"></p>
</li>
</ul>
<p>First, note that<br>$$<br>\begin{aligned}<br>        &amp;   \frac{1}{2} r’(z) + \frac{1}{2} r(x)    \<br>    =   &amp;   \frac{1}{2} \log s’(z) + \frac{1}{2} \log s(x)   \<br>    \le &amp;   \log \left[ \frac{s’(z)}{2}  + \frac{ s(x) }{2} \right] \<br>    &lt;   &amp;   \log \left[ \frac{s(z)}{2}  \right] \<br>\end{aligned}<br>$$</p>
<p>The first inequality follows from that the function $\log (\cdot )$ is concave and the second one follows from $s’(z) + s(x) = s(z) - 1 &lt; s(z)$.</p>
<p>Therefore,<br>$$<br>r’(z) + r(x) \le 2 \left[ r(z) - 1 \right]<br>$$</p>
<p>Now consider the potential change of the zig-zig operation:<br>$$<br>\begin{array}{rll}<br>        &amp;   r’(x) + r’(y) + r’(z) - r(x) - r(y) - r(z) \<br>    =   &amp;   r’(y) + r’(z) - r(x) - r(y) \<br>    \le &amp;   r’(x) + r’(z) - r(x) - r(x) \<br>    =   &amp;   [r’(x) - r(x)]  +[r’(z) + r(x)] - 2 r(x) \<br>    \le &amp;   [r’(x) - r(x)] +2[r(z) - 1] - 2 r(x) \<br>    =   &amp;   3[r’(x) - r(x)] - 2<br>\end{array}<br>$$</p>
<p>The first equality follows from $r’(x) = r(z)$, as $s’(x) = s(z)$. The first inequality holds since $r(x) \le r(y)$.</p>
<h4 id="Zig-Zag"><a href="#Zig-Zag" class="headerlink" title="Zig-Zag"></a><strong><em>Zig-Zag</em></strong></h4><ul>
<li><p>Example.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/ZigZag.png"></p>
</li>
</ul>
<p>First, note that<br>$$<br>\begin{aligned}<br>        &amp;   \frac{1}{2} r’(y) + \frac{1}{2} r’(z)    \<br>    =   &amp;   \frac{1}{2} \log s’(y) + \frac{1}{2} \log s’(z)   \<br>    \le &amp;   \log \left[ \frac{s’(y)}{2}  + \frac{ s’(z) }{2} \right] \<br>    &lt;   &amp;   \log \left[ \frac{s’(x)}{2}  \right] \<br>\end{aligned}<br>$$</p>
<p>The first inequality follows from that the function $\log (\cdot )$ is concave and the second one follows from $s’(y) + s’(z) = s’(x) - 1 &lt; s’(x)$.</p>
<p>Therefore,<br>$$<br>r’(y) + r’(z) \le 2 \left[ r’(x) - 1 \right]<br>$$</p>
<p>Now consider the potential change of the zig-zag operation:<br>$$<br>\begin{array}{rll}<br>        &amp;   r’(x) + r’(y) + r’(z) - r(x) - r(y) - r(z) \<br>    =   &amp;   r’(y) + r’(z) - r(x) - r(y) \<br>    \le &amp;   r’(y) + r’(z) - r(x) - r(x) \<br>    \le &amp;   2 \left[ r’(x) - 1 \right] - 2 r(x) \<br>    =   &amp;   2[r’(x) - r(x)] - 2<br>\end{array}<br>$$</p>
<p>The first equality follows from $r’(x) = r(z)$, as $s’(x) = s(z)$. The first inequality holds since $r(x) \le r(y)$.</p>
<h4 id="Zig"><a href="#Zig" class="headerlink" title="Zig"></a><strong><em>Zig</em></strong></h4><ul>
<li><p>Example.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/SplayTree/Zig.png"></p>
</li>
</ul>
<p>Now consider the potential change of the zig-zag operation:<br>$$<br>\begin{array}{rll}<br>        &amp;   r’(x) + r’(y)  - r(x) - r(y)  \<br>    =   &amp;   r’(y)  - r(x)  \<br>    \le &amp;   r’(x)  - r(x)<br>\end{array}<br>$$</p>
<p>$\blacksquare$</p>
<p>We now show the implementation of basic BST operations and their amortized cost. Throughout the analysis we assume that $w(x) = 1$. </p>
<h3 id="Cost-of-Insertion"><a href="#Cost-of-Insertion" class="headerlink" title="Cost of Insertion"></a>Cost of Insertion</h3><p>Inserting a node $x$ is the same as that in a BST.  Then we splay node $x$ to the root.   We charge the cost of going down the tree by the cost of splaying $x$, which has amortized cost $O(\log n)$. It is left to analyze the change of $\Phi$. Let $root = x_1, x_2, …, x_k, x_{k + 1} = x$ be the root to $x$ path right after inserting $x$. The insertion of $x$ increases  $s(x_1), s(x_2), …, s(x_{k })$ by 1, therefore,<br>$$<br>\begin{array}{llr}<br>\Delta \Phi &amp;= \sum_{i = 1}^k \log \frac{s(x_i) + 1 }{s(x_i)} \<br>            &amp;= \log \prod_{i = 1}^k \frac{s(x_i) + 1 }{s(x_i)} \<br>            &amp;\le \log \frac{s(x_1) + 1}{ s(x_k ) }<br>\end{array}<br>$$<br>The last inequality follows from that $s(x_i) \ge s(x_{i + 1}) + 1$ for $i \in [k]$. Therefore, $\Delta \Phi = O(\log n)$ and the overall amortized cost of insertion is $O(\log n)$. </p>
<p>Remark: $key(x_{k})$ is either the predecessor or successor of $key(x)$.   </p>
<h3 id="Cost-of-Search"><a href="#Cost-of-Search" class="headerlink" title="Cost of Search"></a>Cost of Search</h3><p>Whether the search is successful or not, we splay the last accessed node to the root and charge the cost of going down the tree to the splay-operations. Therefore, the amortized cost is $O(\log n)$. </p>
<p>Remark: in case of unsuccessful search, we find either the predecessor or successor of the search key. </p>
<h3 id="Cost-of-Deletion"><a href="#Cost-of-Deletion" class="headerlink" title="Cost of Deletion"></a>Cost of Deletion</h3><p>As in a BST, deletion is a little bit tricky. Let $x$ be the node to delete and $y$ be its parent (if exists). There are 3 cases</p>
<ul>
<li><p>If $x$ is a leaf node, then we just delete it and splay $y$ to the root. </p>
</li>
<li><p>If $x$ has only one child, we replace $x$ with its child as the child of $y$. Then we delete $x$ and splay $y$ to the root. </p>
</li>
</ul>
<p>The final case uses the first two cases as a sub-routine. We first discuss the amortized cost of the first two cases. The cost of going down to $x$ can be charged to the cost of splaying $y$ to the root, which has amortized cost $O(\log n)$. Deleting the node decreases the potential function, which will only lower the overall amortized cost. Therefore, the amortized cost of deletion is bounded by $O(\log n)$. </p>
<ul>
<li>If $x$ has two children, we find the predecessor node $pred(x)$ of $x$, which is the node with largest key in $x$’s left sub-tree. Note that $pred(x)$ has at most one child. Then we delete the node $pred(x)$. This reduces to case 1 or case 2. Finally we replace the $key(x)$ with $key(pred(x))$. </li>
</ul>
<p>In the following sections we analyze the properties of the splay tree on a sequence $S$ of $m$ operations. </p>
<h2 id="Static-Optimality"><a href="#Static-Optimality" class="headerlink" title="Static Optimality"></a>Static Optimality</h2><p>Suppose that $S$ consists of only successful search operations. Let $p_i &gt; 0<br>$ be the frequency that the $i^{th}$ element is accessed.  Define a static binary search tree to be the one whose structure is fixed. In particular, it can not perform rotations. </p>
<p><strong><em>Theorem.</em></strong> (Static Optimality) The total cost of  $S$ performed on the splay tree is at most a constant times the minimum possible cost of $S$ performed a static binary search tree, plus $O(m )$. </p>
<p><em>Proof.</em>  Let $T^*$ be the static binary search tree that minimizes the cost of $S$. For the $i^{th}$ element, let $l_i$ be the depth of $i$ in $T^*$, i.e. the number of nodes on the path from $i$ to the root, so $l(root) = 1$. The total cost in $T^*$ is given by $\sum_{i = 1}^n p_i \cdot m \cdot l_i$. We are going to prove that the cost for splay tree is<br>$$<br>O(m + \sum_{i = 1}^n p_i \cdot m \cdot l_i)<br>$$<br>Suppose that $T^*$ has maximum depth $d_{max}(T^*)$. We claim that for any $k &lt; d_{max}(T^*)$, $T^*$ must contain exactly $2^k$ nodes with depth $k$. Otherwise, we can cut some leaf node from its parent and pad it into the $i^{th}$ level. This will only decrease the access cost,  contradicting $T^*$ being the optimal static binary tree. Then, $d_{max}(T^*) \le \lfloor \log_2 n \rfloor + 1$ and<br>$$<br>\sum_{i = 1}^n 3^{-l_i} \le \frac{1}{2} \sum_{k = 1}^{ \lfloor \log_2 n \rfloor + 1 } (\frac{2}{3})^k \le 1<br>$$<br>To investigate the time for splay tree, we choose a different weight than earlier and just set $w_i = 3^{-l_i}$. Now the amortized cost of accessing $i^{th}$ element is given by<br>$$<br>O(1 + \log_2 \frac{s(root)}{s(i)}) = O(1 + \log_2 \frac{1}{3^{-l_i}}) = O(1 + l_i)<br>$$<br>Let $c_k$ be the actual cost of the $k^{th}$ operation in $S$ and $a_k$ be the amortized cost. Further, let $\Phi_k$ be the potential of the splay tree after the $k^{th}$ operation. Then<br>$$<br>\sum_{k = 1}^m a_k = \sum_{k = 1}^m (c_k + \Phi_k - \Phi_0) = \sum_{k = 1}^m c_k + \Phi_m - \Phi_0<br>$$<br>Hence, the actual cost on this sequence is bounded by<br>$$<br>\begin{aligned}<br>\sum_{k = 1}^m c_k &amp;= \Phi_0 - \Phi_m + \sum_{k = 1}^m a_k \<br>&amp;=    \Phi_0 - \Phi_m + \sum_{i = 1}^m p_i \cdot m \cdot \log 3^{l_i} \<br>&amp;=  \Phi_0 - \Phi_m + \sum_{i = 1}^m p_i \cdot m \cdot (l_i \log 3 + 1)  \<br>&amp;= m + \Phi_0 - \Phi_m + \sum_{i = 1}^m p_i \cdot m \cdot l_i \cdot \log 3<br>\end{aligned}<br>$$<br>It is left to bound $\Phi_0 - \Phi_m$. Let $r^0(i)$ be the rank of $i^{th}$ before and $r^m(i)$ be the rank after the operations. It holds that $r^0(i) \le \log_2 1 = 0$ and $r^m(i) \ge \log_2 w(i)$. Now,<br>$$<br>\begin{aligned}<br>\Phi_0 - \Phi_m &amp;= \sum_{i = 1}^n \left( r^0(i) - r^m(i) \right) \<br>&amp;\le \sum_{i  = 1}^n \log 3^{l_i} \<br>&amp;=  \sum_{i =1}^n l_i \log 3 \<br>\end{aligned}<br>$$<br>Under the assumption that each item is accessed at  least once, we know $p_i \cdot m \ge 1$ and $\Phi_0 - \Phi_m \in O(\sum_{i = 1}^m p_i \cdot m \cdot l_i \cdot \log 3 )$. </p>
<p><strong><em>Remark</em></strong>. Of course, we could bound<br>$$<br>\sum_{i =1}^n l_i \log 3 \le (1 + 2 \cdot 2 + 3 \cdot 2^2 + 4 \cdot 2^3 + … + (\lfloor \log_2 n \rfloor + 1) \cdot 2^{ \lfloor \log_2 n \rfloor }) \log 3<br>$$<br>Let $\Sigma=1 + 2 \cdot 2 + 3 \cdot 2^2 + 4 \cdot 2^3 + … +  (\lfloor \log_2 n \rfloor + 1) \cdot 2^{ \lfloor \log_2 n \rfloor }$, then<br>$$<br>2 \cdot \Sigma - \Sigma = (\lfloor \log_2 n \rfloor + 1) \cdot 2^{ \lfloor \log_2 n \rfloor + 1} - \sum_{i = 0}^{\lfloor \log_2 n \rfloor - 1} 2^i \in O(n \log n)<br>$$</p>
<p>Note that $n \log n$ is a lower bound of the access cost of the optimal static binary search tree, under the assumption that each item is accessed at least once. </p>
<p><strong><em>Remark</em></strong>:</p>
<p>In general,<br>$$<br>\sum_{i = 0}^k x^i = \frac{x^{k + 1} - 1}{x - 1}<br>$$<br>Applying $x \cdot \frac{\partial}{\partial x}$ to both sides,<br>$$<br>\begin{aligned}<br>\sum_{i = 1}^k i x^{i}<br>&amp;= x \cdot \frac{(k + 1) x^k (x - 1) - (x^{k + 1} - 1)}{(x - 1)^2} \<br>&amp;= x \cdot \frac{(k + 1) (x^{k +1} - x^k) - (x^{k + 1} - 1)}{(x - 1)^2} \<br>&amp;= x \cdot \frac{ k x^{k +1} - (k + 1) x^k  + 1}{(x - 1)^2} \<br>&amp;= x \cdot \left( \frac{k x^k }{x - 1} - \frac{ x^k  - 1}{(x - 1)^2} \right)\<br>\end{aligned}<br>$$</p>
<h2 id="Working-Set-Property"><a href="#Working-Set-Property" class="headerlink" title="Working Set Property"></a>Working Set Property</h2><p>Suppose that $S = {x_1, x_2, …, x_m}$ and let $t(k)$ be the number of  different nodes accessed before $x_k$ since the last access of node $x_k$, or since the beginning of the sequence if $x_k$ is the first access. </p>
<p><strong><em>Theorem</em>.</strong>  The overall cost of $S$ on the splay tree is bounded by<br>$$<br>O(m + n \log n + \sum_{k = 1}^n \log t(k) )<br>$$<br><strong><em>Proof.</em></strong>  We maintain $w(x) = \frac{1}{(j + 1)^2}$, if the sequence accesses $j$ different nodes since the last accessed of node $x$, or $w(x) = \frac{1}{n^2}$ if it is never accessed before. By definition of $t(k)$, we have $w(x_k) = \frac{1}{(t(x_k) + 1)^2}$. Now<br>$$<br>W \doteq \sum_{x \in T}^n w(x) \in O(1)<br>$$<br>For a node $x_k$ , if it is accessed for the first time, the amortized cost is<br>$$<br>O(1 + \log \frac{W}{w(x_k)} ) = O(\log n) = O(\log t(k))<br>$$<br>Summing over all nodes $x$ in the splay tree $T$, we get $O(n \log n)$.</p>
<p>Otherwise, if an item $x_k$ is accessed before, the amortized cost of accessing $x_k$ is<br>$$<br>O\left( 1 + \log \frac{W}{w(x_k) } \right) = O \left( 1 + \log t(k) \right)<br>$$<br>After each access of a node $x_k$ and splaying it to the root, we modify the weights of the nodes as follows: for all node $x$ with $t(x) &lt; t(x_k)$ (the nodes accessed after the last access of $x_k$), we set<br>$$<br>w(x) = \frac{1}{(t(x) + 1)^2}<br>$$<br>This guarantees that $w(x_k) = {1} / {(1 + t(k))^2}$ for $k \in [m]$. </p>
<p>The weight of the root does not change but the weight of other nodes may decrease after the reassignment. Therefore, the overall potential decreases. The amortized cost of the this access only decreases and is still bounded by $O(1 + \log t(k))$.</p>
<p>Hence<br>$$<br>\sum_{k = 1}^m a_k \in O(n \log n + m + \sum_{k = 1}^m \log t(k) )<br>$$<br>Finally, it is easy to see that $\Phi_0 - \Phi_m \in O(n \log n)$. Therefore,<br>$$<br>\sum_{k = 1}^m c_k \in O(n \log n + m + \sum_{k = 1}^m \log t(k) )<br>$$<br>$\blacksquare$</p>
<h2 id="Static-Finger-Property"><a href="#Static-Finger-Property" class="headerlink" title="Static Finger Property"></a>Static Finger Property</h2><p>The static finger property states that splay tree achieves some kind of locality. Suppose we order the nodes in the tree in increasing order according to their keys and labels them as $1, 2, …, n$. For a node $x$, we use $\pi(x)$ to denote its order. </p>
<p><strong><em>Theorem.</em></strong> For any fixed $i \in [n]$, the total cost of $S$ on the splay tree is bounded by<br>$$<br>O(n \log n + m + \sum_{k = 1}^m \log (|\pi(x_k) - i| + 1) )<br>$$<br><strong><em>Proof.</em></strong> For $x \in T$, we set $w(x) = \frac{1}{(|pi(x) - i| + 1)^2}$. Then<br>$$<br>W \doteq \sum_{x \in T} \in O(1)<br>$$<br>and the amortized cost of accessing $x_k$ is<br>$$<br>O(1 + \log \frac{W}{w(x_k)}) = O(1 + \log (|\pi(x_k) - i| + 1))<br>$$<br>The theorem then follows from $\Phi_0 - \Phi_m = O(n \log n)$. </p>
<p>$\blacksquare$.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]. Sleator, D.D. and Tarjan, R.E., 1983. A data structure for dynamic trees. Journal of computer and system sciences, 26(3), pp.362-391.</p>
<p>[2]. Jelani Nelson, Lecture 7, CS 224: Advanced Algorithms.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/23/Total-Law-of-Variance/" rel="prev" title="Total Law of Variance">
      <i class="fa fa-chevron-left"></i> Total Law of Variance
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/30/Integer-Shortest-Path/" rel="next" title="Integer Shortest Path">
      Integer Shortest Path <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Operations"><span class="nav-number">1.</span> <span class="nav-text">Basic Operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Time-Analysis"><span class="nav-number">2.</span> <span class="nav-text">Time Analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proof-of-The-Access-Lemma"><span class="nav-number">2.1.</span> <span class="nav-text">Proof of The Access Lemma.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Zig-Zig"><span class="nav-number">2.1.1.</span> <span class="nav-text">Zig-Zig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Zig-Zag"><span class="nav-number">2.1.2.</span> <span class="nav-text">Zig-Zag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Zig"><span class="nav-number">2.1.3.</span> <span class="nav-text">Zig</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cost-of-Insertion"><span class="nav-number">2.2.</span> <span class="nav-text">Cost of Insertion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cost-of-Search"><span class="nav-number">2.3.</span> <span class="nav-text">Cost of Search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cost-of-Deletion"><span class="nav-number">2.4.</span> <span class="nav-text">Cost of Deletion</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Static-Optimality"><span class="nav-number">3.</span> <span class="nav-text">Static Optimality</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Working-Set-Property"><span class="nav-number">4.</span> <span class="nav-text">Working Set Property</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Static-Finger-Property"><span class="nav-number">5.</span> <span class="nav-text">Static Finger Property</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">6.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description">你生之前悠悠千載已逝，未來還會有千年沉寂的期待</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WOW</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
