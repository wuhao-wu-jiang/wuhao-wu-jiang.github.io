<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Quake Heap [1] is a min heap (or max heap) that supports the following operations:     Operation Amortized Time    insert(x) $O(1)$   decrease-key(x,k) $O(1)$   delete-min() $O(\log n)$   with $O(n)$">
<meta property="og:type" content="article">
<meta property="og:title" content="Quake Heap">
<meta property="og:url" content="http://example.com/2020/04/02/QuakeHeap/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:description" content="Quake Heap [1] is a min heap (or max heap) that supports the following operations:     Operation Amortized Time    insert(x) $O(1)$   decrease-key(x,k) $O(1)$   delete-min() $O(\log n)$   with $O(n)$">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/Insertion.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-5-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-6-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-7-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-1.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeight.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeightAndInsertion.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-1.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-2.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-3.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-4.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-5.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-6.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-7.jpg">
<meta property="article:published_time" content="2020-04-02T08:23:49.000Z">
<meta property="article:modified_time" content="2020-05-05T00:57:54.000Z">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/Insertion.jpg">

<link rel="canonical" href="http://example.com/2020/04/02/QuakeHeap/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Quake Heap | WOW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WOW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/02/QuakeHeap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="你生之前悠悠千載已逝，未來還會有千年沉寂的期待">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Quake Heap
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-02 19:23:49" itemprop="dateCreated datePublished" datetime="2020-04-02T19:23:49+11:00">2020-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 10:57:54" itemprop="dateModified" datetime="2020-05-05T10:57:54+10:00">2020-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Quake Heap [1] is a min heap (or max heap) that supports the following operations: </p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Amortized Time</th>
</tr>
</thead>
<tbody><tr>
<td>insert(x)</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>decrease-key(x,k)</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>delete-min()</td>
<td>$O(\log n)$</td>
</tr>
</tbody></table>
<p>with $O(n)$ space. For comparison based min heap, either $insert(x)$ or delete-min() takes $O(\log n)$ amortized time. Otherwise, we would have an $o(n \log n)$ comparison based sorting algorithm. </p>
<p>In this blog we walk through its construction step by step and illustrate the philosophy behind. Some of the ideas also appear in other designs of min heaps. </p>
<h3 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h3><p>For insertion we are going to be lazy. Consider inserting the elements 1, 2, 3, 4, 5 into the heap. For each insertion, we just create a singleton node while maintaining a pointer (the “min-pointer”) to the minimum node. The picture below shows the heap we obtain after five insertions. Each insertion has time complexity $O(1)$. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/Insertion.jpg"></p>
<h3 id="Deletion-and-Binomial-Heap"><a href="#Deletion-and-Binomial-Heap" class="headerlink" title="Deletion and Binomial Heap"></a>Deletion and Binomial Heap</h3><p>It would be easier to consider the case delete-min() without decrease-key(x) first. Now we try to delete the minimum element from heap. The first step, of course, is to remove the element $1$, after which we get the following heap. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1.jpg"></p>
<p>Here comes the problem. The “min-pointer” is removed along with the deletion. To maintain it, it seems that we need to loop over the entire list to update the min, which takes $O(n)$ time. If we do nothing else than merely scanning all elements, we need another $O(n)$-scanning for the next deletion. We hope that the comparison performed for the current delete-min operation can reduce the ones we need to perform in the future. </p>
<p>The idea is to merge the elements into trees. <!-- Initially, we view each element as a tree with a single node. Recursively, if the root of tree $A$ is compared with and is less than the root of tree $B$, we make $A$ as a subtree of $B$.  --> Intuitively, the trees “remember” the comparison performed before and save us from comparing the same pairs again.</p>
<p>Various tree structure can be used to record the comparison and this may result in the design of different data structure. The one picked by Quake heap is the tournament tree.  It only compares and merges (linking) two trees of the same height. A new node is created as the root of the two trees. The new node’s value equals to the smaller one of the roots of the two trees. </p>
<p>For example, in the following example, both the node 4 and 5 are viewed as trees with height one. We can compare and link the two trees. A new node with value 4 (the smaller value between 4 and 5) is created as the new root of the merged tree. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2.jpg"></p>
<p>We can continue to link node 3 and 2.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3.jpg"></p>
<p>The linking is performed recursively. Noting the the current two trees have the same height, we link them. We need to also update the “min-pointer” during the linking. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4.jpg"></p>
<p>The construction takes $O(n)$ time. But we can charge the cost of these link operations into the creation of the trees’ roots before. We have performed 3 link operations for the four nodes each being the root of a singleton tree. On average, we pay $O(1)$ per operation. To make the amortized argument more vivid, we can think that conceptually we an additional coin for each singleton tree creation. Therefore, before linking, we have four coins as follows:</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1-Coin.jpg"></p>
<p>Merging node 5 and 4 has actual cost $O(1)$ and creates a new tree root. We use the coin of node 5 to pay the actual cost. Element 4 is the new root and it still has a coin. By using the coin idea, we charge (or averaging) the cost of this link operation to the cost of the creation of node 5. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2-Coin.jpg"></p>
<p>Merging node 3 and 2 uses one coin. We use the coin reserved by node 3. After this, the elements 4 and 2 (the elements that are roots of some trees) still have a coin.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3-Coin.jpg"></p>
<p>Merging the two trees left uses one coin. We use the coin reserved by node 4. After this, the element 2 is still a root and still has a coin.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4-Coin.jpg"></p>
<p>In general, we may need to pay more than $O(1)$ for delete-min(). Consider we would like to perform the operation for the following. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-5-Coin.jpg"></p>
<p>We need to remove all nodes on a root-to-leaf path. In this example it is the path that contains element 2.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-6-Coin.jpg"></p>
<p>After the removal, some children of the nodes in this root-to-leaf path are now exposed as tree roots. In this example, node 4 and 3 are tree roots. We need to reserve two coins node 4 and 3. The coins are reserved for potential linking performed in the future. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-7-Coin.jpg"></p>
<p>Finally we need to compare and link any two trees of the same height, in a recursive manner. This part is paid by the coins reserved for the tree roots. </p>
<p>To analyze the amortized running time of delete-min(), we define the height of the tree as $H$. We need to remove $H$ nodes from the root-to-leaf path, expose $\max {H - 1, 0 }$ node as tree roots and reserve coins for them, followed by recursively linking two trees with the same height. The final step is “free” and covered by the coins reserved. Therefore the amortized cost is $H + \max {H - 1, 0} = \max { 2H - 1, H } \le 2H$. </p>
<p><em>Key Observation:</em>  </p>
<blockquote>
<p><strong><em>To bound the time of delete-min() to $O(\log n)$, it is critical to control the size of $H$.</em></strong> </p>
</blockquote>
<p>To analyze how large $H$ could be, we study how it grow. Initially, a tree with $H  = 1$ contains only 1 key. When we link two trees with $H = 1$, the new tree has height $H = 2$ and $2$ keys (although it has $3$ nodes). In general, a tree with height $H = h$ contains $2^{h - 1}$ keys and this can be easily proved by induction. </p>
<blockquote>
<p>If there is no decrease-key operation, the tree with height $h$ has $2^{h - 1}$ keys and $2^h - 1$ nodes. As there are at most $n$ keys, the maximum possible height, denoted as $H$, is bounded by $\log n$. </p>
</blockquote>
<p>The heap we have constructed so far has a special name called “Binomial Heap”. </p>
<h3 id="Decrease-Key"><a href="#Decrease-Key" class="headerlink" title="Decrease-Key"></a>Decrease-Key</h3><p>If there is only insert() and decrease-key() operation, min heap is easy to implemented. We can use a linked list / dynamic array, while maintaining the min pointer / min index. </p>
<p>If we need to incorporate delete-min() operation, the decrease-key(x) itself is still easy, while the former requires significant modification. For decrease-key(x), we adopt a lazy strategy. If after decreasing, $x$’s value is still smaller than its parent (or $x$ is the root of the tree and has no parent), then everything is fine. For example, if we decrease $4$ to $3.5$ (the node 4 has parent 2), then we do not need to modify the tree after the operation.</p>
<img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-1.jpg" alt="drawing" width="330" />


<p>On the other hand, if we decrease 4 to 1, then its value is smaller than its parent 2. </p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg"></p>
<p>We need to detach the highest node containing value 4 from its parent node (in the meanwhile we maintain the “min-pointer”).</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg"></p>
<p>The only concern with this operation is the height of a heap. In the previous, the tree on the right hand side has height $3$ but contains only two keys. For a tree with $n$ keys, it could happens that it height is $\omega(\log n)$. Indeed, it could be as large as $O(n)$. This will invalidate the strategy we propose in the last section, which requires the height to be $O(\log n)$, to achieve the $O(\log n)$ amortized complexity for delete-min(). </p>
<p>There are various ways to fix this, the idea of which will give rise to Pairing heap [<em>Pairing heap achieve $O(\log n)$ amortized bound for deletion but requires $O(\log n)$ amortized time for both insertion and decrease-key(x). Its design philosophy is closely related to Splay tree.</em>], Fibonacci heap, etc. Here we discuss about the solution of Quake heap. </p>
<p>First, Quake heap records the number of nodes at each height explicitly, denoted as $n_1, n_2, …, n_H$, where $H$ is the maximum possible height. Further, it specifies a parameter $\alpha \in (0, 5, 1)$ and maintains the invariant that $n_{i + 1} \le \alpha \cdot n_i$ for each $i \ge 1$. This guarantees that $H = O(\log n)$. </p>
<p>In the following discussion, we take $\alpha = 0.75$. </p>
<p>Let’s discuss how the maintain the invariant $n_{i + 1} \le \alpha n_i$ for all $i \ge 1$ for insert(x), decrease-key(x) and delete-min() operation. </p>
<ol>
<li><p>For the operation insert(x), it create a singleton node at the bottom layer and increases $n_1$ by 1. If the invariant holds before insertion, it holds afterward. </p>
<p> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeight.jpg"></p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeightAndInsertion.jpg"></p>
</li>
<li><p>For decrease, it will not change the number of nodes at each height. The following example shows the case where the children whose key is decreased is detached from its parent.<br><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg"></p>
<p> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg"></p>
</li>
<li><p>Delete-min is the most difficult part. To maintain the invariant, now delete-min() consists of four part: </p>
<ul>
<li>Delete the min key (and all nodes that contain the min key). As before, this step may expose some children of the deleted nodes as new tree roots. </li>
<li>Recursively link all trees of the same height. After linking, scan all trees to maintain the min pointer. </li>
<li>Quake: if there is a level $i$ such that $n_{i + 1} &gt; \alpha n_i$, remove all nodes with level greater than $i$. </li>
</ul>
</li>
</ol>
<p>It is left to analyze the running time step by step. We use a potential function for analysis. By previous section, the potential should contain the number of trees. Further, by the last step of delete-min operation, it is suggested to includes the number of nodes in the potential function, to cover the cost of node removal. Inspired by this, our first design is given by<br>$$<br>\Phi = # \text{nodes} + 2 \cdot # \text{trees}<br>$$</p>
<p>We analyze the time for each step of delete-min()</p>
<ol>
<li><p>Before delete-min(), the invariant holds and therefore the maximum height $H = O(\log n)$. Deleting the min-key and its associated nodes take actual time $O(\log n)$. As for $\Phi$, the number of nodes decreases (indeed, this decrease will cover the removal of the nodes containing the min key) and the number of trees increases by at most $O(\log n)$.  Therefore, the amortized cost for the first step is $O(\log n)$. </p>
</li>
<li><p>Linking two trees of the same height has actual cost $1$. It creates a new node and decreases the number of trees by 1. Therefore, $\Delta \Phi = -1$. Hence the amortized cost is 0. This also explains why we need an coefficient 2 associated with #trees in the potential function. It is left to analyze the cost of scanning all tree. After linking, all trees are of different height. It suffices to show that the maximum  height is $O(\log n)$ to bound the scanning cost to $O(\log n)$. Before linking $H = O(\log n)$. As there are only $n$ keys, there are at most $n$ trees with height $H$ before and during the linking procedure. Linking $n$ trees of the same height results in a new tree with height $\log n$. Therefore, after linking, $H$ increases by at most $\log n$ and $H = O(\log n)$ still holds. Therefore, the amortized cost for the second step is $O(\log n)$. </p>
</li>
<li><p>Suppose in this step we delete $k$ nodes. The actual cost is $k$. However, the number of nodes decreases by $k$. It seems that the amortized cost is 0 for this step. But it isn’t. We have increased the number of tree. Denote $d_{i + 1}$ the number of nodes at level $i + 1$ with two children before removal and $s_{i + 1}$ the number of nodes with only one children. We have $n_{i + 1} = d_{i + 1} + s_{i + 1}$. On the other hand, we know $n_i \ge 2 d_{i + 1} + s_{i + 1}$. By the fact that $n_{i + 1} &gt; \alpha n_i$, we know that<br> $$<br> \begin{aligned}<br> s_{i + 1} </p>
<pre><code> &amp;= 2(d_&#123;i + 1&#125; + s_&#123;i + 1&#125;) - (2 d_&#123;i + 1&#125; + s_&#123;i + 1&#125;)\\
 &amp;\ge 2 n_&#123;i + 1&#125; - n_i \\
 &amp;\ge (2 \alpha - 1) n_i 
</code></pre>
<p> \end{aligned}<br> $$</p>
<p> as we create at most $n_i$ new trees, we can charge the creation of new trees into $s_{i + 1}$ and modify the potential as<br> $$<br> \Phi = # \text{nodes} + 2 \cdot # \text{trees} + \frac{2}{2\alpha - 1} # \text{nodes with one child}<br> $$</p>
<p> Now step 3 has amortized cost 0. For other steps, this modification will increase the cost of decrease-key(x) by at most $O(1)$. </p>
<p> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-1.jpg"><br> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-2.jpg"><br> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-3.jpg"><br> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-4.jpg"><br> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-5.jpg"><br> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-6.jpg"><br> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-7.jpg"></p>
<p>Caveat: we can’t swap the order of step 2 and step 3, since linking tree may create violation to the invariant and we need step 3 to fix this. </p>
</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Chan, Timothy M. “Quake heaps: a simple alternative to Fibonacci heaps.” In Space-Efficient Data Structures, Streams, and Algorithms, pp. 27-32. Springer, Berlin, Heidelberg, 2013.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/01/Ball%20and%20Bins/" rel="prev" title="Ball and Bins">
      <i class="fa fa-chevron-left"></i> Ball and Bins
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/11/k-Core-Decomposition/" rel="next" title="k-Core Decomposition">
      k-Core Decomposition <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Insertion"><span class="nav-number">1.</span> <span class="nav-text">Insertion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deletion-and-Binomial-Heap"><span class="nav-number">2.</span> <span class="nav-text">Deletion and Binomial Heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decrease-Key"><span class="nav-number">3.</span> <span class="nav-text">Decrease-Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">4.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description">你生之前悠悠千載已逝，未來還會有千年沉寂的期待</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WOW</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
