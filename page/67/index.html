<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Helvetica:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="WOW">
<meta property="og:url" content="http://example.com/page/67/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/67/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/67/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>WOW</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">WOW</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">你生之前悠悠千載已逝<br>未來還會有千年沉寂的期待</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">201</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/10/10/Chernoff%20Bounds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | WOW">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/10/10/Chernoff%20Bounds/" class="post-title-link" itemprop="url">Chernoff Bounds</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-10-10 15:23:14" itemprop="dateCreated datePublished" datetime="2015-10-10T15:23:14-04:00">2015-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-02-09 05:22:35" itemprop="dateModified" datetime="2023-02-09T05:22:35-05:00">2023-02-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- > Last Updated: May-21st-2021 -->
<p>Let <span class="math inline">\(X_1, \ldots , X_n \in \{ 0, 1
\}\)</span> be <span class="math inline">\(n\)</span> independent
Poisson trials. For each <span class="math inline">\(i \in [n]\)</span>,
define <span class="math inline">\(\mu_i \doteq \mathbb{E}
[X_i]\)</span>. Let <span class="math inline">\(X \doteq \sum_{i \in [n]
} X_i\)</span> and <span class="math inline">\(\mu \doteq \mathbb{E}
\left[ X \right]\)</span>.</p>
<!-- $$ \small
\begin{aligned} 
    X &\doteq \sum_{i \in [n] } X_i, \\
    \mu &\doteq \mathbb{E} \left[ \sum_{i \in [n] } X_i \right] = \sum_{i \in [n] } \mu_i. 
\end{aligned}
$$ -->
<blockquote>
<p><strong>Theorem 1.</strong><br />
For all <span class="math inline">\(\epsilon &gt; 0\)</span>, <span
class="math display">\[
\Pr[X \ge (1 + \epsilon)\mu] \le \left( \frac{e^\epsilon}{ (1 +
\epsilon)^{1 + \epsilon} } \right)^\mu.
\]</span> For all <span class="math inline">\(\epsilon \in (0,
1)\)</span>, <span class="math display">\[
\Pr \left[ X \ge (1 + \epsilon) \cdot \mu \right] \le e ^ {- \epsilon^2
\mu / 3}.
\]</span></p>
</blockquote>
<p><strong>Proof</strong>: Noting that <span
class="math inline">\(e^x\)</span> is a non- decreasing function and by
applying <em>Markov's Inequality</em>, for any <em>t &gt; 0</em>, we
obtain <span class="math display">\[
\begin{aligned}
    \Pr \left[ X \ge (1 + \epsilon) \cdot \mu \right]
    &amp; = \Pr \left[ e^{tX} \ge e^{ (1 + \epsilon) t \mu } \right] \\
    &amp; \le \frac{\mathbb{E} \left[ e^{tX} \right] }{e^{(1 +
\epsilon)t\mu} }.
    \end{aligned}
\]</span></p>
<p>From independence of <span class="math inline">\(X_i\)</span>, we get
<span class="math display">\[
\begin{aligned}
    \mathbb{E} \left[ e^{tX} \right]
    &amp;= \prod \mathbb{E} \left[ e^{t X_i} \right] \\
    &amp; = \prod (e^t \mu_i + (1 - \mu_i)) \\
    &amp; = \prod(1 + \mu_i (e^t -1)) \\
    &amp;\le \prod e^{ \mu_i (e^t - 1)} \\
    &amp;= e^{\mu (e^t -1)}.
\end{aligned}
\]</span></p>
<p>Hence: <span class="math display">\[
    \Pr \left[ X \ge (1 + \epsilon) \cdot \mu \right] \le
\frac{\mathbb{E} \left[ e^{tX} \right] }{ e^{ (1 + \epsilon)t\mu} } =
\frac{e^{\mu (e^t -1)} }{e^{(1 + \epsilon)t\mu} }.
\]</span></p>
<p>By minimizing the inequality over t, we have <span
class="math display">\[
    \Pr[X \ge (1 + \epsilon)\mu] \le \underset{t &gt; 0}{\min }
\frac{e^{\mu (e^t -1)} }{e^{(1 + \epsilon)t\mu} }.
\]</span></p>
<p>It can be shown that when <span class="math inline">\(t = \ln (1 +
\epsilon )\)</span>, the bound is tightest: <span
class="math display">\[
    \Pr[X \ge (1 + \epsilon)\mu] \le e ^ {\mu ( \epsilon - ( 1 +
\epsilon) \ln(1 + \epsilon))} = \left( \frac{e^\epsilon}{ (1 +
\epsilon)^{1 + \epsilon} } \right)^\mu.
\]</span></p>
<p>By Taylor series expansion for <span class="math inline">\(\ln(1 +
\epsilon)\)</span>, <span class="math display">\[
\begin{aligned}
    (1 + \epsilon)\ln(1 + \epsilon) &amp;= \epsilon +
\sum_{i=2}^{\infty} (-\epsilon)^i \left( \frac{1}{i - 1} -  \frac{1}{i}
\right) \\
    &amp; \ge \epsilon + \epsilon^2
    \frac{1}{2} - \epsilon^3 \frac{1}{6} \\
    &amp; \ge \epsilon + \epsilon^2 \frac{1}{3}.  
    \end{aligned}
\]</span></p>
<p>Substitute it back into the inequality, we obtain the desired result:
<span class="math display">\[
    \Pr[X \ge (1 + \epsilon)\mu] \le e ^ {- \epsilon^2 \frac{\mu}{3} }.
\]</span></p>
<blockquote>
<p><strong>Theorem 2</strong> For all <span
class="math inline">\(\epsilon \in (0, 1)\)</span>, <span
class="math display">\[
\Pr[X \le (1 - \epsilon)\mu] \le e ^ {- \epsilon^2 \frac{\mu}{2} }.
\]</span></p>
</blockquote>
<p><strong>Proof</strong>: As before, <span class="math display">\[
\begin{aligned}
    \Pr \left[ X \le (1 - \epsilon) \mu \right]
    &amp; = \Pr \left[ e^{-tX} \ge e^{-(1 - \epsilon) t \mu} \right] \\
    &amp; \le \frac{ \mathbb{E} \left[ e^{-tX} \right] }{e^{-(1 -
\epsilon) t \mu} } \\
    &amp; \le  \frac{e^{ (1 - \epsilon) t \mu} }{e^{ \mu(e^t -1) } }.
\end{aligned}
\]</span></p>
<p>Let <span class="math inline">\(t = \ln (1 + \epsilon )\)</span>,
<span class="math display">\[
    \Pr \left[ X \le (1 - \epsilon) \cdot \mu \right] \le
    e ^ {\mu ( (  1 - \epsilon) \ln(1 + \epsilon) - \epsilon ) }.
\]</span></p>
<p>Applying Taylor expansion, we get <span class="math display">\[
\begin{aligned}
    (1 - \epsilon)\ln(1 + \epsilon) &amp;= \epsilon +
\sum_{i=2}^{\infty} (-\epsilon)^i \left(- \frac{1}{i - 1} +  \frac{1}{i}
\right) \\
    &amp; \ge \epsilon - \epsilon^2 \frac{1}{2}.
\end{aligned}
\]</span></p>
<p>Finally, <span class="math display">\[
    \Pr \left[ X \le (1 - \epsilon) \cdot \mu \right] \le e ^ {-
\epsilon^2 \frac{\mu}{2} }.
\]</span></p>
<p><span class="math inline">\(\square\)</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/08/08/Reading-Notes-on-Introduction-to-Complexity-Chapter-Two/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | WOW">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/08/08/Reading-Notes-on-Introduction-to-Complexity-Chapter-Two/" class="post-title-link" itemprop="url">Context-Free Languages</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-08-08 20:03:17" itemprop="dateCreated datePublished" datetime="2015-08-08T20:03:17-04:00">2015-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-04-02 16:28:33" itemprop="dateModified" datetime="2025-04-02T16:28:33-04:00">2025-04-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="pushdown-automata">Pushdown Automata</h1>
<p>Pushdown automata resemble nondeterministic finite automata but have
access to unlimited memory, modeled as a stack that operates on a
<em>first-in, last-out</em> (FILO) principle.</p>
<blockquote>
<p><strong>Definition.</strong> A <strong>pushdown automaton</strong> is
a six-tuple <span class="math inline">\(\langle Q, \Sigma, \Gamma,
\delta, S, F \rangle\)</span>, where</p>
<ul>
<li><span class="math inline">\(Q\)</span> is a finite set of
states,</li>
<li><span class="math inline">\(\Sigma\)</span> is a finite set of input
symbols,</li>
<li><span class="math inline">\(\Gamma\)</span> is a finite set of stack
symbols,</li>
<li><span class="math inline">\(\delta : Q \times \Sigma_{\epsilon}
\times \Gamma_{\epsilon} \to P(Q \times \Gamma_\epsilon)\)</span> is the
transition function, where <span class="math inline">\(\Sigma_{\epsilon}
= \Sigma \cup \{ \epsilon \}\)</span>, <span
class="math inline">\(\Gamma_\epsilon = \Gamma \cup \{ \epsilon
\}\)</span>, and <span class="math inline">\(P(Q \times
\Gamma_\epsilon)\)</span> is the power set of <span
class="math inline">\(Q \times \Gamma_\epsilon\)</span>,</li>
<li><span class="math inline">\(S \in Q\)</span> is the start state
and</li>
<li><span class="math inline">\(F \subseteq Q\)</span> is a finite set
of accept states.</li>
</ul>
</blockquote>
<p>At the core of a pushdown automaton's definition is its transition
function. The next move is determined by three elements from the domain
<span class="math inline">\(Q \times \Sigma_{\epsilon} \times
\Gamma_{\epsilon}\)</span>:<br />
- <strong>The current state.</strong><br />
- <strong>The next input symbol</strong> <span
class="math inline">\(\sigma \in \Sigma_\epsilon\)</span>:<br />
- If <span class="math inline">\(\sigma=\epsilon\)</span>, the machine
moves without consuming input.<br />
- <strong>The symbol</strong> <span class="math inline">\(\gamma \in
\Gamma_\epsilon\)</span> <strong>at the top of the stack:</strong><br />
- If <span class="math inline">\(\gamma=\epsilon\)</span>, the machine
moves without reading or popping the stack.<br />
- Otherwise, the machine pops <span
class="math inline">\(\gamma\)</span> from the stack.</p>
<p>The machine transitions to a new state and updates the stack based on
a pair from the domain <span class="math inline">\(Q \times
\Gamma_\epsilon\)</span>:<br />
- It enters a (possibly new) state.<br />
- It may push a symbol <span class="math inline">\(\gamma \in
\Gamma_\epsilon\)</span> onto the stack:<br />
- If <span class="math inline">\(\gamma=\epsilon\)</span>, no symbol is
written.</p>
<h2 id="example-operations">Example Operations</h2>
<p>If we want the automaton to move to state <span
class="math inline">\(q_1\)</span> and push a symbol <span
class="math inline">\(\gamma \in \Gamma\)</span> onto the stack when the
machine is in state <span class="math inline">\(q_0\)</span> and reads
input <span class="math inline">\(\sigma\)</span>, we specify the
transition function <span class="math inline">\(\delta\)</span> by
including <span class="math inline">\((q_1, \gamma)\)</span> in <span
class="math inline">\(\delta(q_0, \sigma, \epsilon)\)</span>.</p>
<p>Conversely, if we want the automaton to move to state <span
class="math inline">\(q_1\)</span> and pop the symbol on top of the
stack when<br />
- the machine is in state <span
class="math inline">\(q_0\)</span>,<br />
- reads input <span class="math inline">\(\sigma\)</span>, and<br />
- the symbol on top of the stack is <span class="math inline">\(\gamma
\in \Gamma\)</span>,</p>
<p>we specify the transition function <span
class="math inline">\(\delta\)</span> by including <span
class="math inline">\((q_1, \epsilon)\)</span> in <span
class="math inline">\(\delta(q_0, \sigma, \gamma)\)</span>.</p>
<h2 id="computation">Computation</h2>
<p>A pushdown automaton <span class="math inline">\(M = \langle Q,
\Sigma, \Gamma, \delta, S, F \rangle\)</span> computes as follows. It
accepts input <span class="math inline">\(w\)</span> if <span
class="math inline">\(w\)</span> can be written as <span
class="math inline">\(w = w_1 w_2 \ldots w_m\)</span>, where each <span
class="math inline">\(w_i \in \Sigma_\epsilon\)</span>, and sequences of
states <span class="math inline">\(r_0, r_1, \ldots, r_m \in Q\)</span>
and strings <span class="math inline">\(s_0, s_1, \ldots, s_m \in
\Gamma^*\)</span> exist that satisfy the following three conditions. The
strings <span class="math inline">\(s_i\)</span> represent the sequence
of stack contents that <span class="math inline">\(M\)</span> has on the
accepting branch of the computation.</p>
<ol type="1">
<li><p><strong><span class="math inline">\(r_0 = S\)</span> and <span
class="math inline">\(s_0 = \epsilon\)</span>.</strong> This condition
signifies that <span class="math inline">\(M\)</span> starts properly,
in the start state with an empty stack.</p></li>
<li><p><strong>For <span class="math inline">\(i = 0, \ldots, m -
1\)</span>, we have <span class="math inline">\((r_{i + 1}, b) \in
\delta(r_i, w_{i + 1}, a)\)</span>, where <span
class="math inline">\(s_i = at\)</span> and <span
class="math inline">\(s_{i+1} = bt\)</span> for some <span
class="math inline">\(a, b \in \Gamma_\epsilon\)</span> and <span
class="math inline">\(t \in \Gamma^*\)</span>.</strong> This condition
states that <span class="math inline">\(M\)</span> transitions correctly
based on its state, stack, and input symbol.</p></li>
<li><p><strong><span class="math inline">\(r_m \in F\)</span>.</strong>
This condition ensures that <span class="math inline">\(M\)</span>
reaches an accept state at the end of the input.</p></li>
</ol>
<h2 id="what-can-be-computed-by-pushdown-automata">What can be computed
by Pushdown Automata</h2>
<blockquote>
<p><strong>Theorem.</strong> The class of context-free languages is
closed under union, concatenation, and star operations.</p>
</blockquote>
<h2 id="what-cannt-be-computed-by-pushdown-automata">What cann't be
computed by Pushdown Automata</h2>
<blockquote>
<p><strong>Pumping Lemma.</strong> For every context-free language <span
class="math inline">\(L\)</span>, there is a number <span
class="math inline">\(p\)</span>, such that for every <span
class="math inline">\(\omega \in L\)</span>, if the length of <span
class="math inline">\(\omega\)</span> is greater than <span
class="math inline">\(p\)</span>, then <span
class="math inline">\(\omega\)</span> can be devided into five pieces
<span class="math inline">\(\omega = axyzb\)</span>, satisfying the
following three conditions: 1. <span class="math inline">\(ax^iyz^ib \in
L\)</span>, for all <span class="math inline">\(i \ge 0\)</span>, 2.
<span class="math inline">\(|xyz| \le p\)</span> and 3. <span
class="math inline">\(|x| \ge 0\)</span> or <span
class="math inline">\(|z| \ge 0\)</span>.</p>
</blockquote>
<h1 id="context-free-grammar">Context-Free Grammar</h1>
<blockquote>
<p><strong>Definition.</strong> A <strong>context-free grammar</strong>
is a four-tuple <span class="math inline">\(\langle N, \Sigma, S,
R\rangle\)</span>, where</p>
<ul>
<li><span class="math inline">\(N\)</span> is a finite set of symbols
called the <strong>variables</strong>,</li>
<li><span class="math inline">\(\Sigma\)</span> is a finite set of
symbols, disjoint from <span class="math inline">\(N\)</span>, called
the <strong>terminals</strong>,</li>
<li><span class="math inline">\(S \in N\)</span> is the start symbol,
and</li>
<li><span class="math inline">\(R\)</span> is a finite set of rules,
with each rule of the form <span class="math inline">\(X \to
\omega\)</span>, where <span class="math inline">\(X \in N\)</span> and
<span class="math inline">\(\omega \in (N \cup \Sigma)^+\)</span>.</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Computation.</strong> Let <span class="math inline">\(u, v, w
\in (N \cup \Sigma)^*\)</span>. - Say that <span
class="math inline">\(uAv\)</span> <strong>yields</strong> <span
class="math inline">\(uwv\)</span>, written <span
class="math inline">\(uAv \Rightarrow uwv\)</span>, if there exists a
rule <span class="math inline">\(A \to w\)</span> of the grammar, - Say
that <span class="math inline">\(u\)</span> <strong>derive</strong>s
<span class="math inline">\(v\)</span>, written <span
class="math inline">\(u \stackrel{*}{\Rightarrow} v\)</span>, if <span
class="math inline">\(u = v\)</span> or if a sequence <span
class="math inline">\(u_1, u_2, \ldots, u_k\)</span> exists for <span
class="math inline">\(k \ge 0\)</span> and <span class="math display">\[
u \Rightarrow u_1 \Rightarrow u_2 \Rightarrow \ldots \Rightarrow u_k
\Rightarrow v.
\]</span> The <strong>language of the grammar</strong> is <span
class="math inline">\(\{ w \in \Sigma^* | S \stackrel{*}{\Rightarrow} w
\}\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>Chomsky Normal Form.</strong> A context-free grammar <span
class="math inline">\(\langle N, \Sigma, S, R\rangle\)</span> is in
chomsky normal form if each rule is of one of the two forms</p>
<ul>
<li><span class="math inline">\(X \to YZ\)</span>, where <span
class="math inline">\(X \in N\)</span>, and <span
class="math inline">\(Y, Z \in N \setminus \{ S \}\)</span>,</li>
<li><span class="math inline">\(X \to a\)</span>, where <span
class="math inline">\(X \in N, a \in \Sigma\)</span>.</li>
</ul>
<p>In addition, we permit <span class="math inline">\(S \to
\epsilon\)</span>, where <span class="math inline">\(S\)</span> is the
start variable.</p>
</blockquote>
<h1
id="equivalence-between-context-free-grammar-and-pushdown-automata">Equivalence
between Context-Free Grammar and Pushdown Automata</h1>
<ol type="1">
<li><p>For every context-free grammar <span
class="math inline">\(G\)</span>, there is an automaton <span
class="math inline">\(M\)</span>, such that <span
class="math inline">\(M\)</span> recognizes the language generated by
<span class="math inline">\(G\)</span>.</p></li>
<li><p><strong><em>If a pushdown automaton recognizes some language,
then it is context-free.</em></strong></p></li>
</ol>
<p><strong>Proof</strong>: For the convenience of proof, we modify a
pushdown automaton <span class="math inline">\(M = \langle Q, \Sigma,
\Gamma, \delta, S, F \rangle\)</span> to give it three features:</p>
<blockquote>
<ul>
<li><span class="math inline">\(M\)</span> accepts by entering empty
stack.<br />
</li>
<li>These is only one accept state <span
class="math inline">\(q_{accpet}\)</span> in <span
class="math inline">\(F\)</span>.<br />
</li>
<li>Each transition either pushes a symbol onto the stack or pops one
off the stack, but it does not do both at the same time.</li>
</ul>
</blockquote>
<p>The way to construct a context-free grammar <span
class="math inline">\(G\)</span> from the push-down automaton <span
class="math inline">\(M\)</span> is given by follow: &gt;<em>(1)</em>
<span class="math inline">\(\forall p \in Q\)</span>, we put the rule
<span class="math inline">\(N_{pp} \to \epsilon\)</span> in G.<br />
<em>(2)</em> <span class="math inline">\(\forall p,q,r \in Q\)</span>,
we add to <span class="math inline">\(G\)</span> a new rule <span
class="math inline">\(N_{pq} \to N_{pr} N_{rq}\)</span>,<br />
<em>(3)</em> <span class="math inline">\(\forall p, q, r, s \in
Q\)</span>, if <span class="math inline">\(\exists a, b\in
\Sigma_\epsilon\)</span>, <span class="math inline">\(t \in
\Gamma\)</span>, s.t. <span class="math inline">\((r,t) \in
\delta(p,a,\epsilon)\)</span> and <span
class="math inline">\((q,\epsilon) \in \delta(s,b,t)\)</span>, then we
put the rule <span class="math inline">\(N_{pq} \to a N_{rs}b\)</span>
in <span class="math inline">\(G\)</span>.</p>
<p>It is easy to see that (1) and (2) may give rise to many meaningless
grammar rules, i.e., grammar rules that will never be used to derive
terminal strings. (3) seems to be the only exception at the first
glance. However, it indeed does the same. Consider the following
example,</p>
<figure>
<img
src="https://imglf2.lf127.net/img/Y1FUYmVJRmJqaTIwc0EyUTdZa0dtbFQ4bTJlQ3l4UTVpU2REQ20vSExpOD0.jpg?imageView&amp;thumbnail=1000x0&amp;type=jpg"
alt="pushdown automaton M2" />
<figcaption aria-hidden="true">pushdown automaton M2</figcaption>
</figure>
<p>Some of the grammar productions constructed according to (1), (2),
(3) are:</p>
<table>
<thead>
<tr>
<th>grammar productions</th>
<th>contructed according to [(1)/(2)/(3)]</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(N_{av} \to N_{bc}\)</span></td>
<td>[according to (3)]</td>
</tr>
<tr>
<td><span class="math inline">\(N_{bc} \to N_{bd}N_{dc}\)</span></td>
<td>[according to (2)]</td>
</tr>
<tr>
<td><span class="math inline">\(N_{bd} \to N_{cc}\)</span></td>
<td>[according to (3)]</td>
</tr>
<tr>
<td><span class="math inline">\(N_{cc} \to \epsilon\)</span></td>
<td>[according to (1)]</td>
</tr>
<tr>
<td><span class="math inline">\(N_{dc} \to N_{dt}N_{tc}\)</span></td>
<td>[according to (2)]</td>
</tr>
<tr>
<td><span class="math inline">\(N_{dt} \to N_{es}\)</span></td>
<td>[according to (3)]</td>
</tr>
<tr>
<td><span class="math inline">\(N_{tc} \to N_{uu}y\)</span></td>
<td>[according to (3)]</td>
</tr>
<tr>
<td><span class="math inline">\(N_{uu} \to \epsilon\)</span></td>
<td>[according to (1)]</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>Heading down this way, we can get the grammar for pushdown automaton
<span class="math inline">\(M1\)</span>.<br />
But following (3), we also get productions like: &gt;<span
class="math inline">\(N_{dn} \to N_{em}\)</span><br />
&gt;<span class="math inline">\(N_{ek} \to N_{fj}\)</span></p>
<p>These rules are useless. They can not derive any string of terminals.
To understand the real cause of the problem, take <span
class="math inline">\(N_{dn} \to N_{em}\)</span> for example. When the
push down automaton goes from state <span
class="math inline">\(q_d\)</span> to state <span
class="math inline">\(q_e\)</span>, it pushes a <span
class="math inline">\(Y\)</span> into the stack. And a <span
class="math inline">\(Y\)</span> is poped during the transition from
state <span class="math inline">\(q_m\)</span> to <span
class="math inline">\(q_n\)</span>. But the <span
class="math inline">\(Y\)</span> poped is not the same <span
class="math inline">\(Y\)</span> pushed during the transition from state
<span class="math inline">\(q_d\)</span> to <span
class="math inline">\(q_e\)</span>. At state <span
class="math inline">\(q_n\)</span>, the stack does not recover to its
initial state before the automaton entering state <span
class="math inline">\(q_d\)</span>. Some additional non-terminal symbols
are still in the stack. </br></p>
<p><strong>Now let's look at another automaton M2 that recognizes the
same language as M1.</strong></p>
<figure>
<img
src="https://imglf2.lf127.net/img/Y1FUYmVJRmJqaTIwc0EyUTdZa0dtZ3R6YzUvUnEzanl1c3o0WkJHWXF1RT0.jpg?imageView&amp;thumbnail=1000x0&amp;type=jpg"
alt="pushdown automaton M1" />
<figcaption aria-hidden="true">pushdown automaton M1</figcaption>
</figure>
<p>Interestingly, such unnecessary rules disappear in <span
class="math inline">\(M2\)</span>. See the following rules:</p>
<table>
<thead>
<tr>
<th>grammar productions</th>
<th>contructed according to [(1)/(2)/(3)]</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(N_{dc} \to N_{dj}N_{jc}\)</span></td>
<td>according to (2)</td>
</tr>
<tr>
<td><span class="math inline">\(N_{dj}  \to N_{ec}\)</span></td>
<td>according to (3)</td>
</tr>
<tr>
<td><span class="math inline">\(N_{jc}  \to N_{cc}y\)</span></td>
<td>according to (3)</td>
</tr>
</tbody>
</table>
<p>When the push down automaton goes from state <span
class="math inline">\(q_d\)</span> to state <span
class="math inline">\(q_e\)</span>, it pushes a <span
class="math inline">\(Y\)</span> into the stack. And a <span
class="math inline">\(Y\)</span> is poped during the transition from
state <span class="math inline">\(q_j\)</span> to <span
class="math inline">\(q_c\)</span>. When entering state <span
class="math inline">\(q_j\)</span>, the stack may not be what it is
before going to state <span class="math inline">\(q_d\)</span>. But the
rule <span class="math inline">\(N_{dj}  \to N_{ec}\)</span> is valid.
It can indeed derive terminal strings.</p>
<p>Actually, <span class="math inline">\(M2\)</span> will enter <span
class="math inline">\(q_j\)</span> twice, with <span
class="math inline">\(XY\$\)</span> and <span
class="math inline">\(\$\)</span> in the stack respectively. In the
former case, the automaton will loop on <span
class="math inline">\(q_c\)</span>. It enters the accept state until
<span class="math inline">\(\$\)</span> is left on the stack.</p>
<p><em>The grammar corresponding to <span
class="math inline">\(M2\)</span></em>:</p>
<blockquote>
<p><span class="math inline">\(N_{ak} \to N_{bc}\)</span><br />
<span class="math inline">\(N_{bc} \to N_{bd}N_{dc}\)</span><br />
<span class="math inline">\(N_{bd} \to N_{cc}\)</span><br />
<span class="math inline">\(N_{dc} \to N_{dj}N_{jc}\)</span><br />
<span class="math inline">\(N_{dj} \to N_{ec}\)</span><br />
<span class="math inline">\(N_{ec} \to N_{ei}N_{ic}\)</span><br />
<span class="math inline">\(N_{ei} \to N_{fc}\)</span><br />
<span class="math inline">\(N_{fc} \to N_{fj}N_{jc}\)</span><br />
<span class="math inline">\(N_{fj} \to N_{gc}\)</span><br />
<span class="math inline">\(N_{gc} \to N_{gi}N_{ic}\)</span><br />
<span class="math inline">\(N_{gi} \to N_{hc}\)</span><br />
<span class="math inline">\(N_{hc} \to N_{cc}a\)</span><br />
<span class="math inline">\(N_{jc} \to N_{cc}y\)</span><br />
<span class="math inline">\(N_{ic} \to N_{cc}x\)</span><br />
<span class="math inline">\(N_{cc} \to \epsilon\)</span></p>
</blockquote>
<p>In the book <strong><em>Introduction To Automata Theory, Languages,
and Computation</em></strong>, <strong><em>John E. Hopcroft, Rajeev
Motwani, Jeffery D. Ullman</em></strong> give another way of converting
a pushdown automaton into context-free grammar. In that way, we can
avoid construct meaningless rules even for pushdown automaton <span
class="math inline">\(M1\)</span>. The key idea is, rule like <span
class="math inline">\(N_{pq} \to a N_{rs}b\)</span> is constructed if
and only if in state <span class="math inline">\(q\)</span> the stack is
the same as what it is before the automaton entering state <span
class="math inline">\(p\)</span>.</p>
<p>One more thing to mention about rule(3) &gt; <em>(3)</em> <span
class="math inline">\(\forall p, q, r, s \in Q\)</span>, if <span
class="math inline">\(\exists a, b\in \Sigma_\epsilon, t \in
\Gamma\)</span>, s.t. <span class="math inline">\((r,t) \in
\delta(p,a,\epsilon)\)</span> and <span
class="math inline">\((q,\epsilon) \in \delta(s,b,t)\)</span>, then we
put the rule <span class="math inline">\(N_{pq} \to a N_{rs}b\)</span>
in G.</p>
<p>is that <span class="math inline">\(t\)</span> need not to be <span
class="math inline">\(b\)</span>. We will give an example, though it is
kind of weird.</p>
<figure>
<img src="https://i.imgur.com/NaV9YFA.jpg"
alt="pushdown automaton M3" />
<figcaption aria-hidden="true">pushdown automaton M3</figcaption>
</figure>
<h1 id="reference">Reference</h1>
<p>[1] <em>Introduction To The Theory Of Computation, 2nd Edition, by
Michael Sipser</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2015/08/07/Reading-Notes-on-Introduction-to-Complexity-Chapter-One/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | WOW">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/08/07/Reading-Notes-on-Introduction-to-Complexity-Chapter-One/" class="post-title-link" itemprop="url">Reading Notes on Introduction to Complexity - Chapter One</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-08-07 21:18:14" itemprop="dateCreated datePublished" datetime="2015-08-07T21:18:14-04:00">2015-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-03-23 19:59:48" itemprop="dateModified" datetime="2025-03-23T19:59:48-04:00">2025-03-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="finite-state-automata-dfa">Finite State Automata (DFA)</h1>
<p>We aim to develop a mathematical model of computers based on the
following observations:</p>
<ol type="1">
<li>A computer has internal states.<br />
</li>
<li>It processes inputs from a finite alphabet.<br />
</li>
<li>Its state transitions are determined by the current state and
input.</li>
</ol>
<p>When the number of internal states is finite, the computer can be
modeled as a finite-state automaton.</p>
<blockquote>
<p><strong>Definition.</strong> A finite state automaton is a five-tuple
<span class="math inline">\(\langle Q, \Sigma , \delta, S, F
\rangle\)</span>, where<br />
- <span class="math inline">\(Q\)</span> is a finite set called the
states, - <span class="math inline">\(\Sigma\)</span> is a finite set
called the alphabet, - <span class="math inline">\(\delta : Q \times
\Sigma \to Q\)</span> is a transition function, - <span
class="math inline">\(S \in Q\)</span> is the start state, - <span
class="math inline">\(F \subseteq Q\)</span> is the set of accpet
states.</p>
</blockquote>
<blockquote>
<p><strong>Computation.</strong> Let <span class="math inline">\(M =
\langle Q, \Sigma , \delta, S, F \rangle\)</span> be a finite automaton
and let <span class="math inline">\(w = w_1 w_2 \ldots w_n\)</span> be a
string where each <span class="math inline">\(w_i \in \Sigma\)</span>.
Then <span class="math inline">\(M\)</span> accepts <span
class="math inline">\(w\)</span> if a sequence of states <span
class="math inline">\(r_0, r_1, \ldots, r_n \in Q\)</span> exists with
three conditions: 1. <span class="math inline">\(r_0 = S\)</span>, 2.
<span class="math inline">\(\delta(r_i, w_{i + 1}) = r_{i + 1}\)</span>,
<span class="math inline">\(\forall \, i \in \{ 0, \ldots, n - 1
\}\)</span>, 3. <span class="math inline">\(r_n \in F\)</span>.</p>
</blockquote>
<p>Under these definitions, a finite state automaton is a computer
designed for a specific task. The "algorithm" for performing this task
is hard-wired into the computer, encoded in its internal states and
transition function.</p>
<h2 id="what-can-be-computed-by-the-model">What can be computed by the
model?</h2>
<p>A fundamental question is: what can this mathematical model compute?
We use set operations to explore the computational capabilities of this
model.</p>
<blockquote>
<p><strong>Language.</strong> If <span class="math inline">\(A\)</span>
is the set of all strings that machine <span
class="math inline">\(M\)</span> accepts, we say that <span
class="math inline">\(A\)</span> is the language of machine <span
class="math inline">\(M\)</span> and write <span
class="math inline">\(L(M) = A\)</span>. We say that <span
class="math inline">\(M\)</span> recognizes <span
class="math inline">\(A\)</span> or that <span
class="math inline">\(M\)</span> accepts <span
class="math inline">\(A\)</span>.</p>
<p><strong>Regular Language.</strong> A regular language is the language
that can be recognized by some finite state automaton.</p>
<p><strong>Set Operations.</strong> Let <span
class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> be languages. We define the regular
operations union, concatenation, and star as follows: - Union: <span
class="math inline">\(A \cup B = \{ x \mid x \in A \text{ or } x \in  B
\}\)</span>. - Concatenation: <span class="math inline">\(A \circ B = \{
x y  \mid x \in A \text{ and } y \in  B \}\)</span>. - Star: <span
class="math inline">\(A^∗ = \{ x_1 x_2 \ldots x_k \mid k \ge 0 \text{
and each } x_i \in A \}\)</span>.</p>
</blockquote>
<p>A collection of strings is called a regular language if it can be
"computed" or "recognized" by an automaton.</p>
<p>The following theorem states that if two collections of strings are
regular languages, then there exist automata that can compute their
union, intersection, and concatenation. Moreover, if a collection of
strings is a regular language, there exists an automaton that can
compute its Kleene star.</p>
<blockquote>
<p><strong>Theorem.</strong> The class of regular language is closed
under <em>union</em>, <em>intersection</em>, <em>concatenation</em> and
<em>star</em> operations.</p>
</blockquote>
<p>The theorem for union and intersection operations can be easily
proven based on DFAs. For concatenation and star operations, the proof
is simpler under an equivalent model.</p>
<h2 id="nondeterministic-finite-state-automatanfa">Nondeterministic
Finite State Automata(NFA)</h2>
<blockquote>
<p><strong>Definition.</strong> A nondeterministic finite state
automaton is a five-tuple <span class="math inline">\(\langle Q, \Sigma
, \delta, S, F \rangle\)</span>, where<br />
- <span class="math inline">\(Q\)</span> is a finite set called the
states, - <span class="math inline">\(\Sigma\)</span> is a finite set
called the alphabet, - <span class="math inline">\(\delta : Q \times
\Sigma_{\epsilon} \to P(Q)\)</span> is a transition function, where
<span class="math inline">\(P(Q)\)</span> is the power set of <span
class="math inline">\(Q\)</span>,<br />
- <span class="math inline">\(S \in Q\)</span> is the start state, -
<span class="math inline">\(F \subseteq Q\)</span> is the set of accpet
states.</p>
</blockquote>
<blockquote>
<p><strong>Computation.</strong> Let <span class="math inline">\(M =
\langle Q, \Sigma , \delta, S, F \rangle\)</span> be a finite automaton
and let <span class="math inline">\(w = w_1 w_2 \ldots w_n\)</span> be a
string where each <span class="math inline">\(w_i \in
\Sigma_\epsilon\)</span>. Then <span class="math inline">\(M\)</span>
accepts <span class="math inline">\(w\)</span> if a sequence of states
<span class="math inline">\(r_0, r_1, \ldots, r_n \in Q\)</span> exists
with three conditions: 1. <span class="math inline">\(r_0 = S\)</span>,
2. <span class="math inline">\(r_{i + 1} \in \delta(r_i, w_{i +
1})\)</span>, <span class="math inline">\(\forall \, i \in \{ 0, \ldots,
n - 1 \}\)</span>, 3. <span class="math inline">\(r_n \in
F\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>Theorem.</strong> Every <em>NFA</em> has an equivalent
<em>DFA</em>.</p>
</blockquote>
<h2 id="what-cant-be-computed-by-the-model">What can't be computed by
the model?</h2>
<p>To understand the power of finite automata, it is essential to also
recognize their limitations. The pumping lemma provides a tool for
proving that a language cannot be recognized by any finite
automaton.</p>
<blockquote>
<p><strong>Theorem (Pumping Lemma).</strong> For every regular language
<span class="math inline">\(L\)</span>, there is a number <span
class="math inline">\(p\)</span> where, for every <span
class="math inline">\(\omega \in L\)</span> of length at least <span
class="math inline">\(p\)</span>, <span
class="math inline">\(\omega\)</span> can be devided into three pieces
<span class="math inline">\(\omega = xyz\)</span>, such that<br />
- <span class="math inline">\(xy^iz \in L\)</span>, for every <span
class="math inline">\(i \ge 0\)</span>, - <span
class="math inline">\(|xy| \le p\)</span>, and - <span
class="math inline">\(|y| &gt; 0\)</span>. ​ ​ ​ ​</p>
</blockquote>
<h2 id="regular-expression">Regular Expression</h2>
<p>Regular expression is a popular application of NFA.</p>
<blockquote>
<p><strong>Definition.</strong> Say that <span
class="math inline">\(R\)</span> is a regular expression of an alphabet
<span class="math inline">\(\Sigma\)</span> if <span
class="math inline">\(R\)</span> is 1. <span class="math inline">\(\{ a
\}\)</span> for some <span class="math inline">\(a \in \Sigma\)</span>,
2. <span class="math inline">\(\{ \epsilon \}\)</span>, 3. <span
class="math inline">\(\varnothing\)</span>, 4. <span
class="math inline">\((R_1 \cup R_2)\)</span>, where <span
class="math inline">\(R_1, R_2\)</span> are regular expressions,<br />
5. <span class="math inline">\((R_1 \circ R_2)\)</span>, where <span
class="math inline">\(R_1, R_2\)</span> are regular expressions,<br />
6. <span class="math inline">\((R_1^*)\)</span>, where <span
class="math inline">\(R_1\)</span> is a regular expressions.</p>
<p>When we want to distinguish between a regular expression <span
class="math inline">\(R\)</span> and the language that it describes, we
write <span class="math inline">\(L(R)\)</span> to be the language of
<span class="math inline">\(R\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>Theorem.</strong> Every regular language has a regular
expression that describes it.</p>
</blockquote>
<p><strong>Hint</strong>: Proving that a DFA can be converted into a
regular expression is via a model called <strong>generalized
nondeterministic finite automaton, GNFA</strong>, which is simply
nondeterministic finite automaton wherein the transition arrows may have
any regular expressions as labels, instead of only members of the
alphabet or <span class="math inline">\(\epsilon\)</span>. We focus on a
special form, where there is one arrow goes from every state to every
other state and also from each state to itself, except that</p>
<ul>
<li><p>The start state has no arrows coming in from any other
state.</p></li>
<li><p>There is only a single accept state which is not the same as the
start state, and it has no arrows going to any other state.</p></li>
</ul>
<p>The formal definitions are given below.</p>
<blockquote>
<p><strong>Definition.</strong> A generalized nondeterministic finite
state automaton is a five-tuple <span class="math inline">\(\langle Q,
\Sigma , \delta, S, F \rangle\)</span>, where<br />
- <span class="math inline">\(Q\)</span> is a finite set called the
states, - <span class="math inline">\(\Sigma\)</span> is a finite set
called the alphabet, - <span class="math inline">\(S \in Q\)</span> is
the start state,<br />
- <span class="math inline">\(A \in Q\)</span> is the set of accpet
states,<br />
- <span class="math inline">\(\delta : (Q - F) \times (Q - A) \to
\mathcal{R}\)</span> is a transition function, where <span
class="math inline">\(\mathcal{R}\)</span> is the collection of all
regular expressions over <span
class="math inline">\(\Sigma\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>Computation.</strong> Let <span class="math inline">\(M =
\langle Q, \Sigma , \delta, S, F \rangle\)</span> be a GNFA and let
<span class="math inline">\(w = w_1 w_2 \ldots w_m\)</span> be a string
where each <span class="math inline">\(w_i \in \Sigma_\epsilon\)</span>.
Then <span class="math inline">\(M\)</span> accepts <span
class="math inline">\(w\)</span> if it can be rewritten as <span
class="math inline">\(w = s_1 s_2 \ldots, s_n\)</span>, where each <span
class="math inline">\(s_i \in \Sigma^*\)</span>, such that there exists
a sequence of states <span class="math inline">\(r_0, r_1, \ldots, r_n
\in Q\)</span> with three conditions: 1. <span class="math inline">\(r_0
= S\)</span>, 2. each <span class="math inline">\(s_i \in
L(R_i)\)</span>, where <span class="math inline">\(R_i = \delta(r_i,
r_{i + 1})\)</span> is the regular expression on the arrow from <span
class="math inline">\(r_i\)</span> to <span class="math inline">\(r_{i +
1}\)</span>, 3. <span class="math inline">\(r_n = A\)</span>.</p>
</blockquote>
<p>Every DFA can be transformed into a GNFA. Then, we iteratively remove
states from the GNFA, updating the regular expressions on the arrows at
each step while preserving the accepted language. This process continues
until only two states remain, and the regular expression on the final
arrow represents the desired result.</p>
<h1 id="reference">Reference</h1>
<p>[1] <em>M. Sipser, Introduction to the theory of computation, Third
edition, Cengage Learning, 2013.</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/66/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><span class="page-number current">67</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">WOW</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
