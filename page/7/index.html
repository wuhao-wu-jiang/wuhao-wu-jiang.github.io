<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Helvetica:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="WOW">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>WOW</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">WOW</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">你生之前悠悠千載已逝<br>未來還會有千年沉寂的期待</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">201</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/Advanced-Joint-Convexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | WOW">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/30/Advanced-Joint-Convexity/" class="post-title-link" itemprop="url">Advanced Joint Convexity</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-04-30 16:49:31 / Modified: 09:35:41" itemprop="dateCreated datePublished" datetime="2022-04-30T16:49:31-04:00">2022-04-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Let <span class="math inline">\((\Omega, \mathcal{F})\)</span> be a
measurable space.</p>
<h1 id="alpha-divergence"><span
class="math inline">\(\alpha\)</span>-Divergence</h1>
<blockquote>
<p><strong>Definition.</strong> Given <span class="math inline">\(\alpha
\ge 1\)</span>, measures <span class="math inline">\(\mu, \nu\)</span>
on <span class="math inline">\((\Omega, \mathcal{F})\)</span>, define
the <span class="math inline">\(\alpha\)</span>-divergence from <span
class="math inline">\(\mu\)</span> to <span
class="math inline">\(\nu\)</span> by <span class="math display">\[
D_\alpha (\mu \Vert \nu) \doteq \sup_{S \in \mathcal{F}} \Big( \mu(S) -
\alpha \cdot \nu(S) \Big).
\]</span></p>
</blockquote>
<p>When <span class="math inline">\(\alpha = 1\)</span>, <span
class="math inline">\(D_\alpha (\mu \Vert \nu)\)</span> is the <em>total
variational distance</em> between <span
class="math inline">\(\mu\)</span> and <span
class="math inline">\(\nu\)</span>.</p>
<h1 id="properties">Properties</h1>
<blockquote>
<p><strong>Theorem.</strong> <span class="math inline">\(D_\alpha (\mu
\Vert \nu)\)</span> is non-negative.</p>
</blockquote>
<p><strong>Proof.</strong> Since <span class="math inline">\(\emptyset
\in \mathcal{F}\)</span>, <span class="math display">\[
    D_\alpha (\mu \Vert \nu) \ge \mu(\emptyset) - \alpha \cdot
\nu(\emptyset) = 0.
\]</span> <span class="math inline">\(\square\)</span></p>
<blockquote>
<p><strong>Theorem (Joint Convexity).</strong> Let <span
class="math inline">\(\mu, \nu, \mu&#39;, \nu&#39;\)</span> be measures
on <span class="math inline">\((\Omega, \mathcal{F})\)</span>. For each
<span class="math inline">\(\alpha \ge 1\)</span>, and <span
class="math inline">\(t \in [0, 1]\)</span>, it holds that <span
class="math display">\[
D_\alpha \left( (1 - t) \cdot  \mu + t \cdot \nu \Big\Vert t \cdot
\mu&#39; + (1 - t) \cdot  \nu&#39; \right)
\le
(1 - t) \cdot  D_\alpha \big(  \mu \Vert \mu&#39; \big)
+
t \cdot D_\alpha \big( \nu \Vert \nu&#39; \big).
\]</span></p>
</blockquote>
<p><strong>Proof.</strong> <span class="math display">\[
    \begin{aligned}
        &amp;D_\alpha \left( (1 - t) \cdot  \mu + t \cdot \nu \Big\Vert
t \cdot \mu&#39; + (1 - t) \cdot  \nu&#39; \right) \\
        =
        &amp;\sup_{S \in \mathcal{F}} \Big(
            (1 - t) \cdot  \mu(S) + t \cdot \nu(S)
            -
            \alpha \Big(
                (1 - t) \cdot  \mu&#39;(S) + t \cdot \nu&#39;(S)
            \Big)
        \Big) \\
        =
        &amp;\sup_{S \in \mathcal{F}} \Big(
            (1 - t) \cdot  \Big( \mu(S) - \alpha \mu&#39;(S) \Big)
            +
            t \cdot \Big( \nu(S) - \alpha \nu&#39;(S) \Big)
        \Big) \\
        \le
        &amp;\sup_{S \in \mathcal{F}} \Big(
            (1 - t) \cdot  \Big( \mu(S) - \alpha \mu&#39;(S) \Big)
        \Big)
        +
        \sup_{S \in \mathcal{F}} \Big(
            t \cdot \Big( \nu(S) - \alpha \nu&#39;(S) \Big)
        \Big) \\
        =
        &amp; (1 - t) \cdot  D_\alpha (  \mu \Vert \mu&#39; )
        +
        t \cdot D_\alpha ( \nu \Vert \nu&#39; ).
    \end{aligned}
\]</span><br />
<span class="math inline">\(\square\)</span></p>
<blockquote>
<p><strong>Theorem (Advanced Joint Convexity [1]).</strong> Let <span
class="math inline">\(\mu, \mu&#39;\)</span> be probability measures
satisfying <span class="math display">\[
  \mu = (1 - t) \cdot  \mu_0 + t \cdot \mu_1, \quad \mu&#39; = (1 - t)
\cdot  \mu_0 + t \cdot \mu_1&#39;,  
\]</span> for some <span class="math inline">\(t \in [0, 1]\)</span> and
probability measures <span class="math inline">\(\mu_0, \mu_1,
\mu_1&#39;\)</span>. Given <span class="math inline">\(\alpha \ge
1\)</span>, let <span class="math inline">\(\alpha&#39; = 1 + t \cdot
(\alpha - 1)\)</span> and <span class="math inline">\(r = \alpha&#39;  /
\alpha\)</span>. Then the following holds: <span class="math display">\[
  D_{\alpha&#39;} ( \mu \Vert \mu&#39; ) = t \cdot D_\alpha ( \mu_1
\Vert (1 − r) \mu_0 + r \mu_{1}&#39;)
\]</span></p>
</blockquote>
<p><strong>Proof.</strong> For each <span class="math inline">\(S \in
\mathcal{F}\)</span>, we have <span class="math display">\[
    \begin{aligned}
        \mu(S) - \alpha&#39; \mu&#39;(S)
            &amp;= (1 - t) \cdot  \mu_0 (S) + t \cdot \mu_1 (S)
-  \alpha&#39; (1 - t) \cdot  \mu_0 (S) - \alpha&#39; t \cdot
\mu_1&#39;(S) \\
            &amp;=  t \cdot \left( \mu_1 (S)  - \alpha&#39;
\mu_1&#39;(S) \right) - (1 - t) \cdot  \left( \alpha&#39; - 1  \right)
\mu_0 (S) \\
            &amp;=  t \cdot \left( \mu_1 (S)  - \alpha \left(
\frac{\alpha&#39;}{\alpha} \mu_1&#39;(S)  +  \frac{(1 - t) \cdot
(\alpha&#39; - 1)}{t\alpha} \mu_0 (S) \right) \right)
    \end{aligned}
\]</span></p>
<p>The following conditions are equivalent <span class="math display">\[
    \begin{array}{lrl}
        &amp;1 - \alpha&#39; / \alpha &amp;= (1 - t) \cdot (\alpha&#39;
- 1) / (t \cdot \alpha), \\
        \Longleftrightarrow\,
        &amp;t \cdot \alpha - t \cdot \alpha&#39; &amp;= \alpha&#39; - t
\cdot \alpha&#39; - 1 + t, \\
        \Longleftrightarrow\,
        &amp;1 + t \cdot (\alpha - 1) &amp;= \alpha&#39;.
    \end{array}
\]</span></p>
<p>Therefore, assuming that <span class="math inline">\(1 + t(\alpha -
1) = \alpha&#39;\)</span> holds, and replacing <span
class="math inline">\(\alpha&#39; / \alpha\)</span> with <span
class="math inline">\(r\)</span>, we have <span class="math display">\[
    \mu(S) - \alpha&#39; \mu&#39;(S) = t \cdot \left( \mu_1 (S)  -
\alpha \left( r \mu_1&#39;(S)  +  \big( 1 - r \big) \mu_0 (S) \right)
\right), \quad
    \forall S \in \mathcal{F}.
\]</span></p>
<p>Tanking supremum over both hand sides finishes the proof.</p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="application">Application</h1>
<blockquote>
<p><strong>Definition.</strong> Let <span class="math inline">\(\mu,
\nu\)</span> be measures on <span class="math inline">\((\Omega,
\mathcal{F})\)</span>. Given <span class="math inline">\(\epsilon,
\delta \ge 0\)</span>, <span class="math inline">\(\mu\)</span> and
<span class="math inline">\(\nu\)</span> are <span
class="math inline">\((\epsilon , \delta)\)</span>-close, if <span
class="math display">\[
D_{e^\epsilon} (\mu \Vert \nu) \le \delta,
\qquad
D_{e^\epsilon} (\nu \Vert \mu) \le \delta.
\]</span></p>
</blockquote>
<p>Based on advanced joint convexity, we have the following result.</p>
<blockquote>
<p><strong>Corollary.</strong> Let <span class="math inline">\(\mu,
\mu&#39;\)</span> be probability measures satisfying <span
class="math display">\[
  \mu = (1 - t) \cdot  \mu_0 + t \cdot \mu_1, \quad \mu&#39; = (1 - t)
\cdot  \mu_0 + t \cdot \mu_1&#39;,  
\]</span> for some <span class="math inline">\(t \in [0, 1]\)</span> and
probability measures <span class="math inline">\(\mu_0, \mu_1,
\mu_1&#39;\)</span>. Given <span class="math inline">\(\epsilon \ge
0\)</span>, let <span class="math inline">\(\epsilon&#39; = \ln \left(1
+ t \cdot (e^\epsilon - 1) \right)\)</span> and <span
class="math inline">\(r = e^{\epsilon&#39;}  / e^{\epsilon}\)</span>.
Combined with joint convexity, the following holds: <span
class="math display">\[
\begin{aligned}
D_{e^{\epsilon&#39;}} ( \mu \Vert \mu&#39; )
&amp;= t \cdot D_{e^{\epsilon}} ( \mu_1 \Vert (1 − r) \mu_0 + r
\mu_{1}&#39;)  \\
&amp;\le t \cdot \Big( (1 − r) \cdot D_{e^{\epsilon}} ( \mu_1 \Vert
\mu_0 ) + r \cdot D_{e^{\epsilon}} ( \mu_1 \Vert \mu_{1}&#39;) \Big) \\
&amp;\le t \cdot \max \Big( D_{e^{\epsilon}} ( \mu_1 \Vert \mu_0 ), \,
D_{e^{\epsilon}} ( \mu_1 \Vert \mu_{1}&#39;) \Big).
\end{aligned}
\]</span></p>
</blockquote>
<p>Based on this corollary, suppose we know that <span
class="math inline">\(\mu_0\)</span> and <span
class="math inline">\(\mu_1\)</span> are <span
class="math inline">\((\epsilon, \delta)\)</span>-close, and that <span
class="math inline">\(\mu_1\)</span> and <span
class="math inline">\(\mu_1&#39;\)</span> are <span
class="math inline">\((\epsilon, \delta)\)</span>-close, then <span
class="math inline">\(\mu\)</span> and <span
class="math inline">\(\mu&#39;\)</span> are <span
class="math inline">\((\epsilon&#39;, t \delta)\)</span> close. If <span
class="math inline">\(\epsilon \le 1\)</span>, then <span
class="math display">\[
    \begin{array}{l}
        &amp;e^{\epsilon&#39;} = 1 + t \cdot (e^\epsilon - 1) \\
        \Longleftrightarrow
        &amp;e^{\epsilon&#39;} - 1 = t \cdot (e^\epsilon - 1) \\
        \Longleftrightarrow
        &amp;\epsilon&#39; \approx t \cdot \epsilon.
    \end{array}
\]</span></p>
<p>In comparison, if we apply the joint convexity directly, we only get
<span class="math display">\[
    D_{e^{\epsilon}} ( \mu \Vert \mu&#39; ) =
    t \cdot D_{e^{\epsilon}} ( \mu_1 \Vert \mu_1&#39; ),
\]</span> and conclude that <span class="math inline">\(\mu\)</span> and
<span class="math inline">\(\mu&#39;\)</span> are <span
class="math inline">\((\epsilon, t \delta)\)</span>-close. There is no
amplification of <span class="math inline">\(\epsilon\)</span>.</p>
<h1 id="reference">Reference</h1>
<p>[1] <em>B. Balle, G. Barthe, and M. Gaboardi, “Privacy Amplification
by Subsampling: Tight Analyses via Couplings and Divergences,”
arXiv:1807.01647 [cs, stat], Nov. 2018, Accessed: Apr. 29, 2022.
[Online]. Available: http://arxiv.org/abs/1807.01647</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/28/k-Center/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | WOW">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/28/k-Center/" class="post-title-link" itemprop="url">k-Center</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-04-28 22:35:10 / Modified: 09:54:27" itemprop="dateCreated datePublished" datetime="2022-04-28T22:35:10-04:00">2022-04-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="problem">Problem</h1>
<p>Let <span class="math inline">\(G = \langle V, E \rangle\)</span> be
an undirected and complete graph, with a distance <span
class="math inline">\(d(v, u) \in \mathbb{R}^+\)</span> between each
pair of <span class="math inline">\(v, u \in V\)</span>. Assume that</p>
<ul>
<li><span class="math inline">\(d(v, v) = 0\)</span> for each <span
class="math inline">\(v \in V\)</span>;</li>
<li><span class="math inline">\(d(v, u) = d(u, v)\)</span> for each
<span class="math inline">\(v, u \in V\)</span>;</li>
<li>The distances satisfy triangle inequality: <span
class="math display">\[
  d(v, w) \le d(v, u) + d(u, w), \qquad \forall v, u, w \in V.
\]</span></li>
</ul>
<p>The goal is to find a set <span class="math inline">\(S \subset
V\)</span> with size <span class="math inline">\(|S| = k\)</span>, for
given input parameter <span class="math inline">\(k \in
\mathbb{N}\)</span>, to minimize <span class="math display">\[
    \max_{v \in V} d(v, S),
\]</span> where <span class="math inline">\(d(v, S) \doteq \min_{j \in
S} d(v, u)\)</span> is the distance between <span
class="math inline">\(i\)</span> and its nearest point in <span
class="math inline">\(S\)</span>.</p>
<h1 id="approximation-algorithm">Approximation Algorithm</h1>
<blockquote>
<p><strong>Algorithm <span
class="math inline">\(\mathcal{A}\)</span></strong><br />
1. Pick arbitrary point <span class="math inline">\(v_1\)</span> from
<span class="math inline">\(V\)</span><br />
2. <span class="math inline">\(S \leftarrow \{ v_1 \}\)</span><br />
2. For <span class="math inline">\(t \leftarrow 2\)</span> to <span
class="math inline">\(k\)</span> do<br />
3. <span class="math inline">\(\qquad\)</span> let <span
class="math inline">\(v_t \doteq \underset{v \in V}{\arg \max} \, d(v,
S)\)</span><br />
4. <span class="math inline">\(\qquad\)</span> <span
class="math inline">\(S \leftarrow S \cup \{ v_t \}\)</span></p>
</blockquote>
<p>Denote the optimal solution as <span class="math inline">\(S^* \doteq
\{ v_1^*, \ldots, v_k^* \}\)</span>: <span class="math display">\[
    S^* \doteq \underset{S \subseteq V, |S| = k}{\arg \min} \, \, \left(
\max_{v \in V} d(v, S) \right).
\]</span> We claim that the algorithm outputs a <span
class="math inline">\(2\)</span>-approximate solution to <span
class="math inline">\(S^*\)</span>.</p>
<blockquote>
<p><strong>Theorem.</strong> Algorithm <span
class="math inline">\(\mathcal{A}\)</span> outputs a <span
class="math inline">\(2\)</span>-approximate solution: <span
class="math display">\[
\max_{v \in V} d(v, S) \le 2 \cdot \max_{v \in V} d(v, S^*).
\]</span></p>
</blockquote>
<p><strong>Proof.</strong> We can partition the vertices in <span
class="math inline">\(V\)</span> into <span
class="math inline">\(k\)</span> subsets <span
class="math inline">\(V_1^*, \ldots V_k^*\)</span>, such that <span
class="math display">\[
    V_i^* \doteq \left\{ v \in V: \underset{v^* \in S^*}{\arg \min} \,
d(v, v^*)  = v_i^* \right\}, \qquad \forall i \in [k].
\]</span></p>
<blockquote>
<p><strong>Lemma.</strong> If <span class="math inline">\(u, w\)</span>
belongs to the same subset <span class="math inline">\(V_i^*\)</span>,
then <span class="math display">\[
d(u, w)
\le
d(u, v_i^*) + d(v_i^*, w)
\le
2 \cdot \max_{v \in V} d(v, S^*).
\]</span></p>
</blockquote>
<p>We consider the following two cases:</p>
<p><strong>Case One.</strong> For each <span class="math inline">\(i \in
[k]\)</span>, <span class="math inline">\(|V_i^* \cap S| = 1\)</span>.
Fix an <span class="math inline">\(i \in [k]\)</span>, and let <span
class="math inline">\(v_t \in V_i^* \cap S\)</span>. Then for each <span
class="math inline">\(u \in V_i^*\)</span>, via the lemma, <span
class="math display">\[
    d(u, S) \le d(u, v_t)
    \le
    2 \cdot \max_{v \in V} d(v, S^*).
\]</span> Since <span class="math inline">\(V_i^*, i \in [k]\)</span> is
a partition of <span class="math inline">\(V\)</span>, this holds for
all <span class="math inline">\(u \in V\)</span>.</p>
<p><strong>Case Two.</strong> There exists some <span
class="math inline">\(V_i^*\)</span> contains more than one points in
<span class="math inline">\(S\)</span>. This implies that at some
iteration, the algorithm <span
class="math inline">\(\mathcal{A}\)</span> selects a point <span
class="math inline">\(v_t \in V_i^*\)</span>, even though it has
selected a point <span class="math inline">\(v_t&#39; \in V_i^*\)</span>
in an earlier iteration.</p>
<p>When <span class="math inline">\(v_t\)</span> is selected, via the
lemma, it holds that <span class="math display">\[
    d(v_t, S) \le d(v_t, v_t&#39;) \le 2 \cdot \max_{v \in V} d(v, S^*).
\]</span></p>
<p>Since <span class="math inline">\(v_t\)</span> is the farthest point
from <span class="math inline">\(S\)</span> when it is selected, all
points are within a distance of <span class="math inline">\(2 \cdot
\max_{v \in V} d(v, S^*)\)</span> from <span
class="math inline">\(S\)</span>. This remains true as the algorithm
<span class="math inline">\(\mathcal{A}\)</span> adds more points.</p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="reference">Reference</h1>
<p>[1] <em>D. P. Williamson and D. B. Shmoys, The Design of
Approximation Algorithms. Cambridge: Cambridge University Press,
2011.</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/21/Set-Cover/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | WOW">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/21/Set-Cover/" class="post-title-link" itemprop="url">Set Cover</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-21 17:31:38" itemprop="dateCreated datePublished" datetime="2022-04-21T17:31:38-04:00">2022-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-22 01:28:59" itemprop="dateModified" datetime="2022-04-22T01:28:59-04:00">2022-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="set-cover-problem">Set Cover Problem</h1>
<p>Let <span class="math inline">\(\Omega = \{ a_1, \ldots, a_n
\}\)</span> be a set, and <span class="math inline">\(S_1, \ldots,
S_m\)</span> be subsets of <span class="math inline">\(\Omega\)</span>,
such that <span class="math inline">\(S_j\)</span> is associated with
weight <span class="math inline">\(w_j \in \mathbb{R}^+\)</span> for
each <span class="math inline">\(j \in [m]\)</span>. The goal is solve
the following the following optimization problem <span
class="math display">\[
    \begin{array}{lll}
        &amp;\min_{J \subseteq [m]} &amp;\sum_{j \in J} w_j, \\
        &amp;\text{s.t.}          &amp;\cup_{j \in J} S_j = \Omega  
    \end{array}
\]</span> In case where <span class="math inline">\(w_j = 1\)</span> for
each <span class="math inline">\(j \in [m]\)</span>, the problem is
called the <em>unweighted</em> set cover problem.</p>
<h1 id="linear-programming">Linear Programming</h1>
<p>The linear program for the problem is <span class="math display">\[
    \begin{array}{llr}
        \min                &amp;\sum_{j \in [m]} w_j \cdot x_j    \\
        \text{s.t.}         &amp;\sum_{j : a_i \in S_j} x_j \ge
1     &amp;\forall i \in [n]\\
                            &amp;x_j \ge
0                      &amp;\forall j \in [m]
    \end{array}
\]</span></p>
<p>The dual LP of the primal is <span class="math display">\[
    \begin{array}{llr}
        \max                &amp;\sum_{i \in [n]} y_i    \\
        \text{s.t.}         &amp;\sum_{i: a_i \in S_j} y_i \le
w_j     &amp;\forall j \in [m]\\
                            &amp;y_i \ge
0                      &amp;\forall i \in [n]
    \end{array}
\]</span></p>
<h1 id="rounding-the-optimal-primal-solution">Rounding the Optimal
Primal Solution</h1>
<p>For each element <span class="math inline">\(i \in [n]\)</span>, let
<span class="math inline">\(E_i \doteq \{ j \in [m] :  a_i \in S_j
\}\)</span>, and let <span class="math inline">\(C = \max_{i \in [n]}
|E_i|\)</span>.</p>
<p>Suppose that <span class="math inline">\(x_j^*, j \in [m]\)</span> be
the optimal solution to the primal LP.</p>
<blockquote>
<p><strong>Theorem.</strong> <span class="math display">\[
J \doteq \left\{ j \in [m] : x_j^* \ge \frac{1}{C} \right\}
\]</span> is a <span class="math inline">\(C\)</span>-approximate
solution to the set cover problem.</p>
</blockquote>
<p><strong>Proof.</strong> We prove first that <span
class="math inline">\(S_j, j \in J\)</span> is a set cover, then we
prove that it is a <span class="math inline">\(C\)</span> approximate
one.</p>
<p><strong>Feasibility.</strong> Since <span
class="math inline">\(x_j^*\)</span> is the optimal solution to the
primal LP, for each <span class="math inline">\(i \in [n]\)</span>, we
have <span class="math display">\[
    \sum_{j : a_i \in S_j} x_j \ge 1.
\]</span> Therefore, , there exists at least one <span
class="math inline">\(j \in E_i\)</span>, s.t., <span
class="math display">\[
    x_j^* \ge \frac{1}{|E_i|} \ge \frac{1}{C}.
\]</span></p>
<p><strong>Approximation Ratio.</strong> The cost of the approximate
solution is given by <span class="math display">\[
    \sum_{j \in J} w_j
            \le \sum_{j \in J} w_j \cdot \big( x_j^* \cdot C \big)
            \le C \cdot \sum_{j \in [m]} w_j \cdot x_j^*.
\]</span></p>
<p><span class="math inline">\(\square\)</span></p>
<p><strong>Remark.</strong> This is a <span
class="math inline">\(2\)</span>-approximation algorithm for the vertex
cover problem, a special case of the set cover problem.</p>
<h1 id="rounding-the-optimal-dual-solution">Rounding the Optimal Dual
Solution</h1>
<p>Let <span class="math inline">\(y_i^*, i \in [n]\)</span> be the
optimal solution to the dual.</p>
<blockquote>
<p><strong>Theorem.</strong> <span class="math display">\[
J&#39; \doteq \left\{ j \in [m] : \sum_{i: a_i \in S_j} y^*_i = w_j
\right\}
\]</span> is a <span class="math inline">\(C\)</span>-approximate
solution to the set cover problem.</p>
</blockquote>
<p><strong>Proof.</strong> We prove first that <span
class="math inline">\(S_j, j \in J&#39;\)</span> is a set cover, then we
prove that it is a <span class="math inline">\(C\)</span> approximate
one.</p>
<p><strong>Feasibility.</strong> Suppose that there exits an uncovered
element <span class="math inline">\(a_k\)</span>, which implies that for
each <span class="math inline">\(j \in E_k\)</span>, it holds that <span
class="math display">\[
    \sum_{i: a_i \in S_j} y^*_i &lt; w_j.
\]</span> But this implies that we can increase the value of <span
class="math inline">\(y_k^*\)</span>, and therefore increase the value
of <span class="math inline">\(\sum_{i \in [n]} y_i^*\)</span>, without
violating the dual constraints, contradicting the <span
class="math inline">\(y_i^*, i \in [n]\)</span> being optimal.</p>
<p><strong>Approximation Ratio.</strong> The cost of the approximate
solution is given by <span class="math display">\[
    \sum_{j \in J&#39;} w_j
            = \sum_{j \in J&#39;} \left( \sum_{i: a_i \in S_j} y^*_i
\right)
            \le \sum_{i \in [n]} \left( \sum_{i: a_i \in S_j} y^*_i
\right)
            \le C \cdot \sum_{i \in [n]} y^*_i,
\]</span> where the last inequality holds, since each <span
class="math inline">\(y_i^*\)</span> appears in at most <span
class="math inline">\(C\)</span> constraints.</p>
<p><span class="math inline">\(\square\)</span></p>
<p><strong>Remark.</strong> Via <em>complementary slackness</em>, if
<span class="math inline">\(x_j^* &gt; 0\)</span>, we always have <span
class="math display">\[
    \sum_{i : a_i \in S_j} y^*_i = w_j.
\]</span> Since <span class="math inline">\(J \doteq \left\{ j \in [m] :
x_j^* \ge 1 / C \right\}\)</span>, it holds that <span
class="math inline">\(J \subseteq J&#39;\)</span>. Therefore, rounding
the primal solution do no worse than rounding the dual one.</p>
<h1 id="the-primal-dual-method">The Primal-Dual Method</h1>
<p>Rounding the optimal dual solution requires to solve the dual LP
optimally, which could be slow even though the LP can be solved in
polynomial time. The following algorithm overcomes this drawback by
constructing only a feasible dual solution.</p>
<blockquote>
<p><strong>Algorithm.</strong> <strong><span
class="math inline">\(\mathcal{A}_{primal \text{-}
dual}\)</span></strong><br />
1. <span class="math inline">\(y_i \leftarrow 0\)</span>, for each <span
class="math inline">\(i \in [n]\)</span><br />
2. <span class="math inline">\(J \leftarrow \emptyset\)</span><br />
3. <strong>while</strong> <span class="math inline">\(\exists a_k \notin
\cup_{j \in J} S_j\)</span> <strong>do</strong><br />
4. <span class="math inline">\(\qquad\)</span> increase <span
class="math inline">\(y_k\)</span> until some constraint becomes
tight,<br />
6. <span class="math inline">\(\qquad\)</span> i.e., <span
class="math inline">\(\exists S_\ell\)</span> with <span
class="math inline">\(a_k \in S_j\)</span>, s.t., <span
class="math inline">\(\sum_{i: a_i \in S_\ell} y_i =
w_\ell\)</span><br />
7. <span class="math inline">\(\qquad\)</span> <span
class="math inline">\(J \leftarrow J \cup \{ \ell \}\)</span></p>
</blockquote>
<p>Clearly the <span class="math inline">\(y_i, i \in [n]\)</span> is a
feasible solution to the dual.</p>
<blockquote>
<p><strong>Theorem.</strong> Algorithm <span
class="math inline">\(\mathcal{A}_{primal \text{-} dual}\)</span>
returns a <span class="math inline">\(C\)</span>-approximate solution
<span class="math inline">\(J\)</span> to the set cover problem.</p>
</blockquote>
<p><strong>Proof.</strong> We prove first that <span
class="math inline">\(S_j, j \in J\)</span> is a set cover, then we
prove that it is a <span class="math inline">\(C\)</span> approximate
one.</p>
<p><strong>Feasibility.</strong> Suppose that there exits an element
<span class="math inline">\(a_k\)</span> that is not covered by <span
class="math inline">\(J\)</span>, which implies that for each <span
class="math inline">\(j \in E_k\)</span>, it holds that <span
class="math display">\[
    \sum_{i: a_i \in S_j} y_i &lt; w_j.
\]</span> But this implies that we can increase the value of <span
class="math inline">\(y_k\)</span>, and therefore increase the value of
<span class="math inline">\(\sum_{i \in [n]} y_i\)</span>, without
violating the dual constraints, contradicting <span
class="math inline">\(y_i\)</span> being optimal.</p>
<p><strong>Approximation Ratio.</strong> The cost of the approximate
solution is given by <span class="math display">\[
    \sum_{j \in J} w_j
            = \sum_{j \in J} \left( \sum_{i: a_i \in S_j} y_i \right)
            \le \sum_{i \in [n]} \left( \sum_{i: a_i \in S_j} y_i
\right)
            \le C \cdot \sum_{j \in [m]} y_i,
\]</span> where the last inequality holds, since each <span
class="math inline">\(y_i\)</span> appears in at most <span
class="math inline">\(C\)</span> constraints.</p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="randomized-rounding">Randomized Rounding</h1>
<p>We present a randomized algorithm based on the optimal solution <span
class="math inline">\(x_j^*\)</span> for the primal LP.</p>
<p>Let <span class="math inline">\(T \in \mathbb{N}^+\)</span> be a
positive integer to be determined later.</p>
<blockquote>
<p><strong>Algorithm.</strong> <span
class="math inline">\(\mathcal{A}_{rnd}\)</span><br />
1. <strong>for</strong> <span class="math inline">\(t \in [T]\)</span>
<strong>do</strong><br />
2. <span class="math inline">\(\qquad\)</span> <span
class="math inline">\(J_t \leftarrow \emptyset\)</span><br />
3. <span class="math inline">\(\qquad\)</span> <strong>for</strong> each
<span class="math inline">\(j \in [m]\)</span> <strong>do</strong><br />
4. <span class="math inline">\(\qquad\)</span> <span
class="math inline">\(\qquad\)</span> add <span
class="math inline">\(j\)</span> to <span
class="math inline">\(J_t\)</span> with probability <span
class="math inline">\(x_j^*\)</span><br />
5. output <span class="math inline">\(J \leftarrow \cup_{t \in [T]}
J_t\)</span></p>
</blockquote>
<blockquote>
<p><strong>Theorem.</strong> The expected cost of <span
class="math inline">\(J\)</span> is at most <span
class="math inline">\(T \cdot \sum_{j \in [m]} w_j \cdot x_j^*\)</span>.
Further, if <span class="math inline">\(T = 2 \ln n\)</span>, with
probability at least <span class="math inline">\(1 - 1 / n\)</span>,
<span class="math inline">\(J\)</span> is a set cover.</p>
</blockquote>
<p><strong>Proof.</strong></p>
<p><strong>Expected Cost.</strong> Since <span
class="math inline">\(j\)</span> is included in <span
class="math inline">\(J_t\)</span> with probability <span
class="math inline">\(x_j^*\)</span> for each <span
class="math inline">\(j \in [m]\)</span>, by linearity of expectation,
the expected sum of weights of sets in <span
class="math inline">\(J_t\)</span> is given by <span
class="math display">\[
    \sum_{j \in [m]} w_j \cdot x_j^*.
\]</span> Therefore, the expected cost of <span
class="math inline">\(J\)</span> is at most <span
class="math inline">\(T \cdot \sum_{j \in [m]} w_j \cdot
x_j^*\)</span>.</p>
<p><strong>Failure Probability.</strong> The probability that a fixed
<span class="math inline">\(a_i\)</span> is not covered by <span
class="math inline">\(J_t\)</span> is given by <span
class="math display">\[
    \begin{aligned}
        \prod_{j : a_i \in S_j} (1 - x_j^*)
        \le \exp \left( - \sum_{j : a_i \in S_j} x_j^* \right)
        \le \exp (- 1).
    \end{aligned}
\]</span> By independence, the probability that none of the <span
class="math inline">\(J_t\)</span> covers <span
class="math inline">\(a_i\)</span> is at most <span
class="math display">\[
    \big( \exp(-1) \big)^T = \exp(-T) = 1 / n^2.
\]</span> Applying union bound over all element <span
class="math inline">\(a_i \in \Omega\)</span> finishes the proof.</p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="greedy-algorithm">Greedy Algorithm</h1>
<p>Finally, we discuss a greedy algorithm for the set cover problem.</p>
<p>We follows the convention that <span class="math inline">\(x / 0 =
\infty\)</span>, <span class="math inline">\(\forall x \in
\mathbb{R}^+\)</span>.</p>
<blockquote>
<p><strong>Algorithm.</strong> <span
class="math inline">\(\mathcal{A}_{greedy}\)</span><br />
1. <span class="math inline">\(\hat S_j \leftarrow S_j\)</span>, for
each <span class="math inline">\(j \in [m]\)</span><br />
2. <span class="math inline">\(J \leftarrow \emptyset\)</span><br />
3. <strong>while</strong> <span class="math inline">\(\cup_{j \in J} S_j
\neq \Omega\)</span> <strong>do</strong><br />
4. <span class="math inline">\(\qquad\)</span> <span
class="math inline">\(\ell \leftarrow \min_{j \in [m]} \left( w_j /
|\hat S_j| \right)\)</span><br />
7. <span class="math inline">\(\qquad\)</span> <span
class="math inline">\(J \leftarrow J \cup \{ \ell \}\)</span><br />
8. <span class="math inline">\(\qquad\)</span> <span
class="math inline">\(\hat S_j \leftarrow \hat S_j \setminus
S_\ell\)</span>, <span class="math inline">\(\forall j \in
[m]\)</span></p>
</blockquote>
<p>For each <span class="math inline">\(k \in \mathbb{N}^+\)</span>,
define <span class="math inline">\(H_k = \sum_{i \in [k]} 1 /
i\)</span>.</p>
<blockquote>
<p><strong>Theorem.</strong> <span
class="math inline">\(\mathcal{A}_{greedy}\)</span> outputs a <span
class="math inline">\(H_n\)</span> approximate solution <span
class="math inline">\(J\)</span> to the set cover problem.</p>
</blockquote>
<p><strong>Proof.</strong> When an <span
class="math inline">\(\ell\)</span> is added to <span
class="math inline">\(J\)</span>, it is easy to see that <span
class="math inline">\(\hat S_\ell \neq \emptyset\)</span>, as otherwise
<span class="math inline">\(w_\ell / |\hat S_\ell| = \infty\)</span>.
Therefore we can charge the cost of <span
class="math inline">\(w_\ell\)</span> among elements in <span
class="math inline">\(\hat S_\ell\)</span>, with each elements <span
class="math inline">\(a_i \in \hat S_\ell\)</span> obtaining a cost
of<br />
<span class="math display">\[
    y_i \doteq w_\ell / |\hat S_\ell|.
\]</span></p>
<p>Since each <span class="math inline">\(a_i \in \Omega\)</span> is
charged exactly once, it holds that <span class="math display">\[
    \sum_{j \in J} w_j = \sum_{i \in [n]} y_i.
\]</span></p>
<p>Our proof is based on the following lemma.</p>
<blockquote>
<p><strong>Lemma.</strong> For each <span class="math inline">\(j \in
[m]\)</span>, it holds that <span class="math display">\[
\sum_{i : a_i \in S_j} y_i \le w_j \cdot H_{|S_j|}.
\]</span></p>
</blockquote>
<p>We now finish the proof for the theorem, assuming the lemma holds.
Let <span class="math inline">\(D \doteq \max_{j \in [m} |S_j| \le
n\)</span>. For each <span class="math inline">\(i \in [n]\)</span>,
define new variable <span class="math inline">\(\hat y_i = y_i /
H_D\)</span>. Then the <span class="math inline">\(\hat y_i\)</span> is
a feasible solution to the dual LP, and therefore <span
class="math inline">\(\sum_{i \in [n]} \hat y_i \le \text{OPT}\)</span>,
where <span class="math inline">\(\text{OPT}\)</span> is the value of
the optimal solution to the set cover problem. We conclude that<br />
<span class="math display">\[
    \sum_{j \in J} w_j
        = \sum_{i \in [n]} y_i
        = H_D \cdot \sum_{i \in [n]} \hat y_i
        \le H_D \cdot \text{OPT}.
\]</span></p>
<p><em>Proof of the Lemma.</em> Suppose that the solution <span
class="math inline">\(J\)</span> returned by <span
class="math inline">\(\mathcal{A}_{greedy}\)</span> consists <span
class="math inline">\(t\)</span> numbers <span
class="math inline">\(\ell_1, \ldots, \ell_t\)</span>, indexed according
to their orders added to <span class="math inline">\(J\)</span>.</p>
<p>For each <span class="math inline">\(k \in [t]\)</span>, define <span
class="math display">\[
    r_k \doteq \Big| S_j \setminus \big( S_{\ell_1} \cup S_{\ell_2} \cup
\ldots \cup S_{\ell_{k - 1}}) \Big|.
\]</span></p>
<p>Note that <span class="math inline">\(r_k\)</span> is the number of
new elements in <span class="math inline">\(S_j\)</span> that is covered
by sets indexed by <span class="math inline">\(J\)</span>, before <span
class="math inline">\(\ell_k\)</span> is added to <span
class="math inline">\(J\)</span>. For convenience, let <span
class="math inline">\(r_0 = n\)</span>. For each <span
class="math inline">\(k \in [t]\)</span>, define <span
class="math inline">\(c_k = r_k - r_{k - 1}\)</span>. We claim that for
each <span class="math inline">\(k \in [t]\)</span>, it holds that <span
class="math display">\[
    \sum_{i : a_i \in S_j \cap \hat S_{\ell_k}} y_i = c_k \cdot y_i \le
c_k \cdot \frac{w_j}{r_k}.
\]</span></p>
<p>If <span class="math inline">\(S_j \cap \hat S_{\ell_k} =
\emptyset\)</span>, then <span class="math inline">\(c_k = 0\)</span>
and the claim holds trivially. Otherwise, the criteria for picking <span
class="math inline">\(\ell_k\)</span> by <span
class="math inline">\(\mathcal{A}_{greedy}\)</span> ensures that for
each <span class="math inline">\(a_i \in S_j \cap \hat
S_{\ell_k}\)</span>, it holds that <span class="math display">\[
    y_i = \frac{w_{\ell_k} }{|\hat S_{\ell_k}|} \le \frac{w_j}{r_k}.
\]</span></p>
<p>Therefore, <span class="math display">\[
    \begin{aligned}
        \sum_{i : a_i \in S_j} y_i
            &amp;= \sum_{k \in [t]} \sum_{i : a_i \in S_j \cap \hat
S_{\ell_k}} y_i \\
            &amp;\le \sum_{k \in [t]} c_k \cdot \frac{w_j}{r_k} \\
            &amp;\le \sum_{k \in [t]} w_j \left( \frac{1}{r_k} +
\frac{1}{r_k - 1} + \ldots + \frac{1}{r_k - c_k + 1} \right) \\
            &amp;= w_j \sum_{k \in \big[ |S_j| \big]} \frac{1}{k} \\
            &amp;= w_j \cdot H_{|S_j|}.
    \end{aligned}
\]</span></p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="reference">Reference</h1>
<p>[1] <em>D. P. Williamson and D. B. Shmoys, The Design of
Approximation Algorithms. Cambridge: Cambridge University Press,
2011.</em></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/67/">67</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">WOW</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
