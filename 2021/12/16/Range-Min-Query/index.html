<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Problem Definition (Range Min Query). Let $a_1, \ldots, a_n \in \mathbb{R}$.Given $\ell, r \in [n]$, $\ell \le r$, return $\min \{ a_\ell, \ldots, a_r \}$.   Basic SolutionsA data structure for the Ra">
<meta property="og:type" content="article">
<meta property="og:title" content="Range Min Query">
<meta property="og:url" content="http://example.com/2021/12/16/Range-Min-Query/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:description" content="Problem Definition (Range Min Query). Let $a_1, \ldots, a_n \in \mathbb{R}$.Given $\ell, r \in [n]$, $\ell \le r$, return $\min \{ a_\ell, \ldots, a_r \}$.   Basic SolutionsA data structure for the Ra">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/01.png?raw=true">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/02.png?raw=true">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/03.png?raw=true">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/04.png?raw=true">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/05.png?raw=true">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/06.png?raw=true">
<meta property="article:published_time" content="2021-12-16T12:36:24.000Z">
<meta property="article:modified_time" content="2022-01-08T06:33:51.249Z">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/01.png?raw=true">

<link rel="canonical" href="http://example.com/2021/12/16/Range-Min-Query/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Range Min Query | WOW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WOW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你生之前悠悠千載已逝<br>未來還會有千年沉寂的期待</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/16/Range-Min-Query/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Range Min Query
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-16 23:36:24" itemprop="dateCreated datePublished" datetime="2021-12-16T23:36:24+11:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-08 17:33:51" itemprop="dateModified" datetime="2022-01-08T17:33:51+11:00">2022-01-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><blockquote>
<p><strong>Definition (Range Min Query).</strong> Let $a_1, \ldots, a_n \in \mathbb{R}$.<br>Given $\ell, r \in [n]$, $\ell \le r$, return $\min \{ a_\ell, \ldots, a_r \}$. </p>
</blockquote>
<h1 id="Basic-Solutions"><a href="#Basic-Solutions" class="headerlink" title="Basic Solutions"></a>Basic Solutions</h1><p>A data structure for the <strong>Range Min Query (RMQ)</strong> has complexity $\left&lt; p(n), q(n) \right&gt;$ if it has pre-processing and query-answering time $p(n)$ and $q(n)$ on input instance of size $n$, respectively. </p>
<h2 id="mathcal-A-1-Precompute-None"><a href="#mathcal-A-1-Precompute-None" class="headerlink" title="$\mathcal{A}_1$ Precompute-None"></a>$\mathcal{A}_1$ Precompute-None</h2><blockquote>
<p>Scan $a_\ell, \ldots, a_r$ to find the min. </p>
<ul>
<li>This is an $\left&lt; 0, O(n) \right&gt;$ solution.      </li>
</ul>
</blockquote>
<h2 id="mathcal-A-2-Complete-Binary-Tree"><a href="#mathcal-A-2-Complete-Binary-Tree" class="headerlink" title="$\mathcal{A}_2$ Complete Binary Tree"></a>$\mathcal{A}_2$ Complete Binary Tree</h2><blockquote>
<p>Construct a complete binary tree with $a_1, \ldots, a_n$ being the leaf nodes.<br>Each internal node of the tree is augmented with the minimum value of its subtree.     </p>
<ul>
<li>This is an $\left&lt; O(n), O(\log n) \right&gt;$ solution. </li>
</ul>
</blockquote>
<h2 id="mathcal-A-3-Precompute-All"><a href="#mathcal-A-3-Precompute-All" class="headerlink" title="$\mathcal{A}_3$ Precompute-All"></a>$\mathcal{A}_3$ Precompute-All</h2><blockquote>
<p>Create a $n \times n$ table $M$.<br>For each $\ell, r \in [n]$, $\ell \le r$, the $(\ell, r)$-th entry records $\min \{ a_\ell, \ldots, a_r \}$.    </p>
<ul>
<li>This is an $\left&lt; O(n^2), O(1) \right&gt;$ solution. </li>
</ul>
</blockquote>
<ul>
<li><p>$p(n) = O(n^2)$.  </p>
<ul>
<li>Dynamic Programming. </li>
<li>$\forall  \ell, r \in [n], \ell \le r$, <script type="math/tex; mode=display">
    M[\ell, r] = 
        \begin{cases}            
            a_\ell  & \ell = r, \\
            \min \{ M[\ell, r - 1], M[\ell + 1, r] \}, & \ell < r.
        \end{cases}</script></li>
</ul>
</li>
<li><p>$q(n) = O(1)$.</p>
</li>
</ul>
<h2 id="mathcal-A-4-Sparse-Table"><a href="#mathcal-A-4-Sparse-Table" class="headerlink" title="$\mathcal{A}_4$ Sparse Table"></a>$\mathcal{A}_4$ Sparse Table</h2><blockquote>
<p>Create a $n \times \lfloor \log n \rfloor$ table $M$.<br>For each $\ell \in [n], k \in \big[ \lfloor \log n \rfloor \big]$, $r \doteq \ell + \big( 2^k - 1 \big) \le n$, the $(\ell, k)$-th entry records $\min \{ a_\ell, \ldots, a_{\ell + 2^k - 1} \}$.     </p>
<ul>
<li>This is an $\left&lt; O(n \log n), O(1) \right&gt;$ solution. </li>
</ul>
</blockquote>
<ul>
<li><p>$p(n) = O(n \log n)$.  </p>
<ul>
<li>Dynamic Programming. </li>
<li>For each $\ell \in [n], k \in \big[ \lfloor \log n \rfloor \big]$, $r \doteq \ell + \big( 2^k - 1 \big) \le n$, let<script type="math/tex; mode=display">
    M[\ell, k] = 
        \begin{cases}            
            \min \{ a_\ell, a_{\ell + 1} \}  &   k = 1, \\
            \min \{ M[\ell, \ell + 2^{k - 1} - 1], M[r -  2^{k - 1} + 1, r] \}, & \ell < r.
        \end{cases}</script></li>
</ul>
</li>
<li><p>$q(n) = O(1)$.</p>
</li>
</ul>
<h1 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h1><h2 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h2><ol>
<li><p>Pick $s \in \mathbb{N}_+$, and let $m = n / s$.           </p>
</li>
<li><p>Partition $a_1, \ldots, a_n$ into $m$ blocks $B_1, \ldots B_m$, such that $B_1$ contains the first $s$ elements, $B_2$ contains the next $s$ elements, and so on. In general,   </p>
<script type="math/tex; mode=display">
 B_i \doteq \{ a_{ (i - 1) \cdot s + 1 },  \ldots, a_{i \cdot s} \}, \quad \forall i \in [m].</script></li>
<li><p>Denote $b_1, \ldots, b_m$ be the minimum element in $B_1, \ldots B_m$, respectively.         </p>
</li>
</ol>
<h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><ol>
<li><p>Given $\ell, r \in [n]$, $\ell \le r$, consider</p>
<ul>
<li><p>$C_1$ be the collection of indexes of the blocks $B_i \subset \{ a_\ell, \ldots, a_r \}$: </p>
<script type="math/tex; mode=display">
      C_1 \doteq \{ i \in [m] : B_i \subset \{ a_\ell, \ldots, a_r \} \}</script><p>  If $C_1 \neq \emptyset$, let $\ell’ = \min_{i \in C_1} i$ and $r’ = \max_{i \in C_1} i$. </p>
</li>
<li><p>$C_2$ be the collection of indexes of the blocks $B_i$ such that $B_i \nsubseteq \{ a_\ell, \ldots, a_r \}$ and $B_i \cap \{ a_\ell, \ldots, a_r \} \neq \emptyset$</p>
<script type="math/tex; mode=display">
      C_2 \doteq \{  i \in [m] : B_i \cap \{ a_\ell, \ldots, a_r \} \neq \emptyset \wedge B_i \nsubseteq \{ a_\ell, \ldots, a_r \} \}.</script><p>  It must be that $|C_2| \le 2$. </p>
</li>
</ul>
</li>
<li><p>To return $\min \{ a_\ell, \ldots, a_r \}$, return the minimum of </p>
<ul>
<li>$\min_{i \in C_1} b_i$, if $C_1 \neq \emptyset$. </li>
<li><p>$\min_{i \in C_2} \min \big( B_i  \cap \{ a_\ell, \ldots, a_r \}\big)$.</p>
<p>Note that </p>
<ul>
<li>The first one is a range-min query on $b_1, \ldots, b_m$.</li>
<li>The second one consists of range-min queries on the blocks $B_i$ for $i \in C_2$ </li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Approach-One"><a href="#Approach-One" class="headerlink" title="Approach One"></a>Approach One</h2><ol>
<li><p>Suppose we invoke an algorithm $A_{up}$ to answer the range-min query on $b_1, \ldots, b_m$, with complexity $\left&lt; p_1(m), q_1(m) \right&gt;$.</p>
</li>
<li><p>Suppose we invoke an algorithm $A_{down}$ to answer the range-min query range-min queries on the blocks $B_i$ for $i \in C_2$, with complexity $\left&lt; p_2(s), q_2(s) \right&gt;$.   </p>
<!-- Suppose that it has pre-processing $p_1(m)$ and query-answering time $q_1(m)$ for a single block.  -->
</li>
<li><p>Since the set $C_2$ depends on the range min query, to answer arbitrary range min query, we need to run the pre-processing of $A_{down}$ on each block $B_i, i \in [m]$. </p>
</li>
</ol>
<p>This approach has complexity</p>
<script type="math/tex; mode=display">
    \begin{aligned}
        &\left< O \big( n + p_1(m) + m \cdot p_2 (s) \big) , O \big( q_1(m) + q_2 (s) \big) \right> \\
        &= 
        \left< O \big( n + p_1(n / s) + (n / s) \cdot p_2 (s) \big), O \big( q_1(n / s) + q_2 (s) \big) \right>.
    \end{aligned}</script><h2 id="Instantiation"><a href="#Instantiation" class="headerlink" title="Instantiation"></a>Instantiation</h2><h3 id="mathcal-A-5-Two-Level-Precompute-None"><a href="#mathcal-A-5-Two-Level-Precompute-None" class="headerlink" title="$\mathcal{A}_5$ Two-Level Precompute-None"></a>$\mathcal{A}_5$ Two-Level Precompute-None</h3><p>Choose Precompute-None $\mathcal{A}_1$ for both $A_{up}$ and $A_{down}$. </p>
<ul>
<li>Total preprocessing time: $O \big( n \big)$.   </li>
<li>Total query time: $O \big( m + s \big) = O \big( \sqrt{n} \big)$, if $m = s = \sqrt{n}$.    </li>
</ul>
<blockquote>
<p>Hence, it has complexity $\left&lt; O \big( n \big), O \big( \sqrt{n} \big) \right&gt;$.</p>
</blockquote>
<h3 id="mathcal-A-6-Two-Level-Binary-Tree"><a href="#mathcal-A-6-Two-Level-Binary-Tree" class="headerlink" title="$\mathcal{A}_6$ Two-Level Binary Tree"></a>$\mathcal{A}_6$ Two-Level Binary Tree</h3><p>This is just a complete binary tree over $a_1, \ldots, a_n$. Therefore, </p>
<ul>
<li><p>Total preprocessing time: $O \big( n \big)$.   </p>
</li>
<li><p>Total query time: $O \big( \log n \big)$. </p>
</li>
</ul>
<blockquote>
<p>Hence, it has complexity $\left&lt; O \big( n \big), O \big( \log n \big) \right&gt;$.</p>
</blockquote>
<h3 id="mathcal-A-7-Two-Level-Sparse-Table"><a href="#mathcal-A-7-Two-Level-Sparse-Table" class="headerlink" title="$\mathcal{A}_7$ Two-Level Sparse Table"></a>$\mathcal{A}_7$ Two-Level Sparse Table</h3><p>We don’t investigate Precompute-All, as the sparse table is always better. </p>
<p>Choose sparse table $\mathcal{A}_3$ for both $A_{up}$ and $A_{down}$. </p>
<ul>
<li>Total preprocessing time: $O \big( m \log m + m \cdot s \log s \big)$.<br>  Since $m \cdot s = n$, we have <script type="math/tex; mode=display">
      O \Big( m \log m + m \cdot s \log s \Big) = O \Big( \frac{n}{s} \log \frac{n}{s} + n \log s \Big),</script>  which is minimized when <script type="math/tex; mode=display">
      \begin{aligned}
          \frac{n}{s} \log \frac{n}{s} = n \log s
          &\iff \log n - \log s = s \log s \\
          &\iff \log n = \Theta (s \log s ) \\
          &\iff \log \log n = \Theta (\log s). 
      \end{aligned}</script>  Therefore, the pre-processing time is reduced to <script type="math/tex; mode=display">
      O \Big( n \log \log n \Big).</script></li>
</ul>
<ul>
<li>Total query time: $O \big( 1 + 1 \big) = O \big( 1 \big)$.    </li>
</ul>
<blockquote>
<p>Hence, it has complexity $\left&lt; O \big( n \log \log n \big), O \big( 1 \big) \right&gt;$.</p>
</blockquote>
<p><strong>Remark:</strong> <em>Personally I suspect this approach is fast in practice.<br>Since $A_{down}$ involves a linear scan of at most two blocks with size $O(\log n)$, and linear scan is cache-friendly.</em></p>
<p><strong>Remark:</strong> If we apply two level $\mathcal{A}_7$, then the preprocessing time is </p>
<script type="math/tex; mode=display">
    O \Big( m \log \log m + m \cdot s \log \log s \Big) = O \Big( \frac{n}{s} \log \log \frac{n}{s} + n \log \log s \Big),</script><p>Choosing $s = \log \log s$ minimized this to </p>
<script type="math/tex; mode=display">
    O \Big( n \log \log \log \log s\Big).</script><p>Further, the query time remains $O(1)$.</p>
<h3 id="mathcal-A-8-Hybrid-Sparse-Table-and-Precompute-None"><a href="#mathcal-A-8-Hybrid-Sparse-Table-and-Precompute-None" class="headerlink" title="$\mathcal{A}_8$ Hybrid-Sparse Table and Precompute-None"></a>$\mathcal{A}_8$ Hybrid-Sparse Table and Precompute-None</h3><p>Choose sparse table $\mathcal{A}_3$ for $A_{up}$ and Precompute-None $\mathcal{A}_1$ for $A_{down}$. </p>
<ul>
<li><p>Total preprocessing time: $O \big( (n / s) \log (n / s) \big)$.   </p>
</li>
<li><p>Total query time: $O \big( 1 + s \big)$.  </p>
</li>
</ul>
<p>If we choose $s = \log n$, then </p>
<ul>
<li><p>Total preprocessing time: $O \big( n \big)$.   </p>
</li>
<li><p>Total query time: $O \big( \log n \big)$.  </p>
</li>
</ul>
<blockquote>
<p>Hence, it has complexity $\left&lt; O \big( n \big), O \big( \log n \big) \right&gt;$.</p>
</blockquote>
<h3 id="mathcal-A-9-Hybrid-Sparse-Table-and-Binary-Tree"><a href="#mathcal-A-9-Hybrid-Sparse-Table-and-Binary-Tree" class="headerlink" title="$\mathcal{A}_9$ Hybrid-Sparse Table and Binary Tree"></a>$\mathcal{A}_9$ Hybrid-Sparse Table and Binary Tree</h3><p>Choose sparse table $\mathcal{A}_3$ for $A_{up}$ and complete binary tree $\mathcal{A}_2$ for $A_{down}$. </p>
<ul>
<li><p>Total preprocessing time: $O \big( (n / s) \log (n / s) + (n / s)\cdot s \big)$.   </p>
</li>
<li><p>Total query time: $O \big( 1 + \log s \big)$.  </p>
</li>
</ul>
<p>If we choose $s = \log n$, then </p>
<ul>
<li><p>Total preprocessing time: $O \big( n \big)$.   </p>
</li>
<li><p>Total query time: $O \big( \log \log n \big)$.  </p>
</li>
</ul>
<blockquote>
<p>Hence, it has complexity $\left&lt; O \big( n \big), O \big( \log \log n \big) \right&gt;$.</p>
</blockquote>
<p><strong>Remark:</strong> If we apply two level $\mathcal{A}_9$, then the preprocessing time is </p>
<script type="math/tex; mode=display">
    O \big( n + n / s + n / s \cdot s \big) = O(n),</script><p>Further, the query time is</p>
<script type="math/tex; mode=display">
    O \big( \log \log (n / s) + \log \log s \big).</script><p>Unfortunately, this is still $\log \log n$.</p>
<h2 id="Approach-Two"><a href="#Approach-Two" class="headerlink" title="Approach Two"></a>Approach Two</h2><!-- Can we achieve $O(n)$ preprocessing time and $O(1)$ under the hybrid framework? 
Recall that it has
* Total preprocessing time: $O \big( n + p_1(n / s) + (n / s) \cdot p_2 (s) \big)$.   
* Total query time: $O \big( q_1(n / s) + q_2 (s) \big)$.    -->
<p>Can we achieve $\left&lt; O \big( n \big), O \big( 1 \big) \right&gt;$ under approach one?<br>Recall that approach one has complexity</p>
<script type="math/tex; mode=display">
    \begin{aligned}
        \left< O \big( n + p_1(n / s) + (n / s) \cdot p_2 (s) \big), O \big( q_1(n / s) + q_2 (s) \big) \right>.
    \end{aligned}</script><p>Suppose we want to achieve preprocessing time $O(n)$ and query time $O(1)$, then $p_2(s)$ and $q_2(s)$ needs to satisfy that $p_2(s) = s$ and $q_2(s) = 1$.<br>But this is exactly the property we want to achieve!</p>
<p>It seems to be impossible to achieve the desired complexity under the divide and conquer framework.</p>
<p>The key is to observe that the following are two different problems. </p>
<blockquote>
<ol>
<li>Finding a <strong>RMQ</strong> algorithm with complexity $\left&lt; O(n), O(1) \right&gt;$.   </li>
<li>Finding an algorithm that preprocess the all block $B_i$ in $O(n)$ time, such that the range-min query on each $B_i$ can be answered in $O(1)$ time.</li>
</ol>
</blockquote>
<p>For the divide-and-conquer framework to work to achieve complexity $\left&lt; O(n), O(1) \right&gt;$, it suffices to find an algorithm for the second problem. </p>
<!-- ### **Construction** -->
<blockquote>
<p><strong>Theorem.</strong> There exists some $s \in \Theta(\log n)$, such that we can find an algorithm that preprocess the all block $B_i$ in $O(n)$ time, such that the range-min query on each $B_i$ can be answered in $O(1)$ time.</p>
</blockquote>
<p>Denote such an algorithm as $\mathcal{A}^*$.<br>Since $s \in \Theta(\log n)$, choosing sparse table algorithm $\mathcal{A}_3$ to answer the range-min query on $b_1, \ldots, b_m$ incurs additional preprocessing time $O( n / s \cdot \log (n / s) ) = O(n)$.<br>Further, answering a query requires only $O(1)$ time. </p>
<p>It is left to show the construction of $\mathcal{A}^*$.</p>
<h3 id="Block-Type"><a href="#Block-Type" class="headerlink" title="Block Type"></a><strong>Block Type</strong></h3><p>W.L.O.G., consider the first block $B_1 = \{ a_{ 1 },  \ldots, a_{ s} \}$ be a block of $s$ elements.<br>We can construct a binary tree over the elements, such that it satisfies </p>
<blockquote>
<ol>
<li><strong>Min Heap Property:</strong> <em>each node of the tree is the smallest one in the subtree rooted at this node.</em>    </li>
<li>The in-order traversal of the tree gives the array $B_1$.</li>
</ol>
</blockquote>
<p>Such a binary tree is called a <strong>Cartesian Tree</strong> and the <strong><em>type</em></strong> of the block.</p>
<p>On the other hand, suppose we are given a <strong>Cartesian Tree</strong> tree constructed on $B_1$, and suppose that the value of each node of the tree is hidden.<br>Hence, we only know the topology or shape of the binary tree.<br>For all $1 \le \ell \le r \le s$, we can still return the index of the minimum element among $a_\ell, \ldots, a_s$, purely based on the topology of the binary tree. </p>
<p>In this sense, the answers to the RMQ on $B_1$ is entirely determined by its corresponding <strong>Cartesian Tree</strong>.</p>
<h3 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a><strong>Enumeration</strong></h3><p>This motivates the following strategy. </p>
<ol>
<li><p>Enumerate all possible <strong>Cartesian Trees</strong>.  </p>
</li>
<li><p>For each <strong>Cartesian Tree</strong>, invoke the sparse table algorithm $\mathcal{A}_3$ algorithm on this tree, so that all possible range min query for this tree can be answer in $O(1)$ time. </p>
</li>
<li><p>For each block $B_i, i \in [m]$, determine its <strong>Cartesian Trees</strong>.<br>To answer a RMQ on $B_i$, access the pre-computed result on its corresponding <strong>Cartesian Trees</strong>. </p>
</li>
</ol>
<blockquote>
<p><strong>Fact.</strong> The number of distinct <strong>Cartesian Trees</strong> with size $s$ is given by</p>
<script type="math/tex; mode=display">
    \frac{1}{1 + s}\binom{2s}{s}.</script></blockquote>
<p>Therefore, enumerating the <strong>Cartesian Trees</strong>, and constructing sparse tables on them for <strong>RMQ</strong>, take time and space</p>
<script type="math/tex; mode=display">
    \frac{1}{1 + s}\binom{2s}{s} \cdot s \cdot \log s 
    = \Theta \left( \frac{s \cdot \log s}{1 + s} \frac{ \sqrt{2s} \cdot \big( 2s / e \big)^{2s} }{ \Big( \sqrt{s} \cdot \big( s / e \big)^{s} \Big)^2 } \right)
    = \Theta \left( \frac{\log s}{\sqrt{s}} \cdot 2^{2s} \right).</script><p>Choosing $s = \big( 0.5 \cdot \log n \big)$ gives $\Theta( n \cdot \big( \log \log n \big) / \sqrt{\log n}) \subset O(n)$. </p>
<h3 id="Determining-the-Block-Type"><a href="#Determining-the-Block-Type" class="headerlink" title="Determining the Block Type"></a><strong>Determining the Block Type</strong></h3><p>In this section, we show how to construct the corresponding Cartesian Tree given the block $B_1$, and to create a unique identifier $\in O(n)$ for the Cartesian Tree.</p>
<p>We illustrate the idea with an example.<br>In this example, $B_1 = (2, 4, 3, 1)$.<br>We will construct the Cartesian Tree, by including the elements from $B_1$ one by one.<br>Further, we maintain a <em>stack</em> and a <em>stack operation sequence</em>, both of which are initially empty.<br>The stack keeps elements from the right spine of the tree, and the stack operation sequence records the “in stack” and “out stack” operations as we include more elements from $B_1$ into the tree.  </p>
<div style="text-align:center">
<img src="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/01.png?raw=true" width="250" height="" />
</div>

<p>We first include the element $2$ into the tree.<br>Since the tree consists of only one node, it is the root of the tree.<br>It is also the only node in the right spine of the tree, so we put $2$ into the stack, and append $1$ to the stack operation sequence, to record the in-stack operation. </p>
<div style="text-align:center">
<img src="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/02.png?raw=true" width="250" height="" />
</div>

<p>Next we include the element $4$ into the tree.<br>Since the tree satisfies min-heap property, $4$ must be the child of $2$.<br>Since the in-order traversal of the tree gives the array $2, 4$, the node $4$ must be the right child of $2$.<br>We put $4$ into the stack, and append $1$ to the stack operation sequence, to record the in-stack operation. </p>
<div style="text-align:center">
<img src="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/03.png?raw=true" width="250" height="" />
</div>

<p>We want to include the element $3$ into the existing tree.<br>Since after inclusion, the in-order traversal of the tree gives the array $2, 4, 3$, the node $3$ must be in the right spine of the tree.<br>Indeed, this is a general principle for adding a new element into the tree. </p>
<blockquote>
<p><strong>Lemma (In the Right Spine).</strong> For each $j \in [s]$, let $T_j$ be the Cartesian tree constructed on $a_1, \ldots, a_j$.<br>Then $a_j$ be must in the right spine of $T_j$. </p>
</blockquote>
<p><strong>Proof.</strong>    </p>
<ol>
<li>If $a_j$ has right-child in $T_j$, then it is not the last element visited by the in-order traversal of $T_j$. </li>
<li>If $a_j$ has a parent node in $T_j$ and is the left-child of its parent, then it is not the last element visited by the in-order traversal of $T_j$. </li>
</ol>
<p>$\square$</p>
<p>In this case, the right spine consists of $2$ and $4$.<br>We compare $3$ with $4$.<br>As it is smaller than $4$, we pop $4$ out of the stack.<br>We compare $3$ with $2$.<br>As it is larger than $2$, we put $3$ into the stack.<br>We include $3$ as the right-child of $2$, and set $4$ as the left child of $3$.<br>We see that after these operations, the stack still contains the nodes in the right spine of the tree.<br>Further, the min-heap property of the tree is maintained.<br>We append $01$ to the stack operation sequence, to record the out-stack and in-stack operations performed. </p>
<p>We now formally states the rules for adding an element to the right spine. </p>
<blockquote>
<p><strong>Incremental Construction Rule.</strong> For each $1 \le j &lt; s$, let $T_j$ be the Cartesian tree constructed on $a_1, \ldots, a_j$, and suppose that $a_1’ \le a_2’ \ldots \le a_k’$ are the elements in the right spine of $T_j$.<br>Then $a_{j + 1}$ is added to $T_j$ as follows:     </p>
<ol>
<li><p>If $a_{j + 1} &lt; a_1’$, then set $a_1’$ as the left child of $a_{j + 1}$.      </p>
</li>
<li><p>If $a_{j + 1} &gt; a_k’$, then set $a_{j + 1}$ as the right child of $a_k’$.          </p>
</li>
<li><p>Otherwise, there exists $1 \le i &lt; k$, such that $a_i’ \le a_{j + 1} &lt; a_{i + 1}’$. Replace $a_{i + 1}’$ by $a_{j + 1}$ as the right child of $a_i’$, and set $a_{i + 1}’$ as the left child of $a_{j + 1}$.    </p>
</li>
</ol>
</blockquote>
<p>It is easy to verify that after the construction </p>
<ol>
<li>$a_{j + 1}$ is in the right spine of the tree.   </li>
<li>The min-heap property is maintained. </li>
</ol>
<div style="text-align:center">
<img src="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/04.png?raw=true" width="400" height="" />
</div>

<p>We want to include the element $1$ into the existing tree.<br>Since after inclusion, the in-order traversal of the tree gives the array $2, 4, 3, 1$, the node $1$ must be in the right spine of the tree.<br>In this case, the right spine consists of $2$ and $3$.<br>As $1$ is smaller than $2$, we pop $3$ and $2$ out of the stack, put $1$ into the stack, and set $2$ as the left child of $1$.<br>We append $001$ to the stack operation sequence, to record the stack operations performed. </p>
<div style="text-align:center">
<img src="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/05.png?raw=true" width="460" height="" />
</div>

<p>Finally, we pop $1$ out of the stack, and append $0$ to the stack operation sequence, to record the stack operation performed.<br>We perform this operation, so that whatever sequence of $a_1, \ldots, a_s$, the stack operation sequence corresponding to the Cartesian Tree construction procedure stated as above has length $2s$. </p>
<div style="text-align:center">
<img src="https://github.com/wuhao-wu-jiang/BlogImgs/blob/master/RangeMinQuery/06.png?raw=true" width="300" height="" />
</div>

<blockquote>
<p>The construction also reveal an interesting fact: each Cartesian Tree with $s$ node corresponding a $0$-$1$ sequence with length $2s$, such that each prefix of the sequence contains no less $1$’s than $0$’s. </p>
</blockquote>
<p>We know that </p>
<script type="math/tex; mode=display">
    | \{ t \in \{0, 1\}^{2s} : \text{each prefix of } t \text{ contains no less } 1 \text{ than } 0 \} | = \frac{1}{1 + s} \binom{2s}{s},</script><p>which gives a construct proof of the number of binary trees with $s$ nodes. </p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Stanford, CS 166, <a target="_blank" rel="noopener" href="https://web.stanford.edu/class/cs166/lectures/00/Slides00.pdf">Range Minimum Queries</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/22/Random-Variable/" rel="prev" title="Random Variable">
      <i class="fa fa-chevron-left"></i> Random Variable
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/09/Borel-Set/" rel="next" title="Borel Set">
      Borel Set <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Problem"><span class="nav-number">1.</span> <span class="nav-text">Problem</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Basic-Solutions"><span class="nav-number">2.</span> <span class="nav-text">Basic Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mathcal-A-1-Precompute-None"><span class="nav-number">2.1.</span> <span class="nav-text">$\mathcal{A}_1$ Precompute-None</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mathcal-A-2-Complete-Binary-Tree"><span class="nav-number">2.2.</span> <span class="nav-text">$\mathcal{A}_2$ Complete Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mathcal-A-3-Precompute-All"><span class="nav-number">2.3.</span> <span class="nav-text">$\mathcal{A}_3$ Precompute-All</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mathcal-A-4-Sparse-Table"><span class="nav-number">2.4.</span> <span class="nav-text">$\mathcal{A}_4$ Sparse Table</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Divide-and-Conquer"><span class="nav-number">3.</span> <span class="nav-text">Divide and Conquer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Preprocessing"><span class="nav-number">3.1.</span> <span class="nav-text">Preprocessing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Query"><span class="nav-number">3.2.</span> <span class="nav-text">Query</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Approach-One"><span class="nav-number">3.3.</span> <span class="nav-text">Approach One</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Instantiation"><span class="nav-number">3.4.</span> <span class="nav-text">Instantiation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mathcal-A-5-Two-Level-Precompute-None"><span class="nav-number">3.4.1.</span> <span class="nav-text">$\mathcal{A}_5$ Two-Level Precompute-None</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mathcal-A-6-Two-Level-Binary-Tree"><span class="nav-number">3.4.2.</span> <span class="nav-text">$\mathcal{A}_6$ Two-Level Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mathcal-A-7-Two-Level-Sparse-Table"><span class="nav-number">3.4.3.</span> <span class="nav-text">$\mathcal{A}_7$ Two-Level Sparse Table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mathcal-A-8-Hybrid-Sparse-Table-and-Precompute-None"><span class="nav-number">3.4.4.</span> <span class="nav-text">$\mathcal{A}_8$ Hybrid-Sparse Table and Precompute-None</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mathcal-A-9-Hybrid-Sparse-Table-and-Binary-Tree"><span class="nav-number">3.4.5.</span> <span class="nav-text">$\mathcal{A}_9$ Hybrid-Sparse Table and Binary Tree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Approach-Two"><span class="nav-number">3.5.</span> <span class="nav-text">Approach Two</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Block-Type"><span class="nav-number">3.5.1.</span> <span class="nav-text">Block Type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enumeration"><span class="nav-number">3.5.2.</span> <span class="nav-text">Enumeration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Determining-the-Block-Type"><span class="nav-number">3.5.3.</span> <span class="nav-text">Determining the Block Type</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">4.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">176</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WOW</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
