<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Quake Heap [1] is a min heap (or max heap) that supports the following operations:    Operation Amortized Time     insert(x) \(O(1)\)   decrease-key(x,k) \(O(1)\)   delete-min() \(O">
<meta property="og:type" content="article">
<meta property="og:title" content="Quake Heap">
<meta property="og:url" content="http://example.com/2020/04/02/QuakeHeap/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:description" content="Quake Heap [1] is a min heap (or max heap) that supports the following operations:    Operation Amortized Time     insert(x) \(O(1)\)   decrease-key(x,k) \(O(1)\)   delete-min() \(O">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/Insertion.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-5-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-6-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-7-Coin.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-1.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeight.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeightAndInsertion.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-1.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-2.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-3.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-4.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-5.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-6.jpg">
<meta property="og:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-7.jpg">
<meta property="article:published_time" content="2020-04-02T08:23:49.000Z">
<meta property="article:modified_time" content="2020-05-05T00:57:54.000Z">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/Insertion.jpg">

<link rel="canonical" href="http://example.com/2020/04/02/QuakeHeap/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Quake Heap | WOW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WOW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你生之前悠悠千載已逝<br>未來還會有千年沉寂的期待</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/02/QuakeHeap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Quake Heap
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-02 19:23:49" itemprop="dateCreated datePublished" datetime="2020-04-02T19:23:49+11:00">2020-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-05 10:57:54" itemprop="dateModified" datetime="2020-05-05T10:57:54+10:00">2020-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Quake Heap [1] is a min heap (or max heap) that supports the following operations:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Amortized Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>insert(x)</td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td>decrease-key(x,k)</td>
<td><span class="math inline">\(O(1)\)</span></td>
</tr>
<tr class="odd">
<td>delete-min()</td>
<td><span class="math inline">\(O(\log n)\)</span></td>
</tr>
</tbody>
</table>
<p>with <span class="math inline">\(O(n)\)</span> space. For comparison based min heap, either <span class="math inline">\(insert(x)\)</span> or delete-min() takes <span class="math inline">\(O(\log n)\)</span> amortized time. Otherwise, we would have an <span class="math inline">\(o(n \log n)\)</span> comparison based sorting algorithm.</p>
<p>In this blog we walk through its construction step by step and illustrate the philosophy behind. Some of the ideas also appear in other designs of min heaps.</p>
<h3 id="insertion">Insertion</h3>
<p>For insertion we are going to be lazy. Consider inserting the elements 1, 2, 3, 4, 5 into the heap. For each insertion, we just create a singleton node while maintaining a pointer (the "min-pointer") to the minimum node. The picture below shows the heap we obtain after five insertions. Each insertion has time complexity <span class="math inline">\(O(1)\)</span>.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/Insertion.jpg" /></p>
<h3 id="deletion-and-binomial-heap">Deletion and Binomial Heap</h3>
<p>It would be easier to consider the case delete-min() without decrease-key(x) first. Now we try to delete the minimum element from heap. The first step, of course, is to remove the element <span class="math inline">\(1\)</span>, after which we get the following heap.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1.jpg" /></p>
<p>Here comes the problem. The "min-pointer" is removed along with the deletion. To maintain it, it seems that we need to loop over the entire list to update the min, which takes <span class="math inline">\(O(n)\)</span> time. If we do nothing else than merely scanning all elements, we need another <span class="math inline">\(O(n)\)</span>-scanning for the next deletion. We hope that the comparison performed for the current delete-min operation can reduce the ones we need to perform in the future.</p>
<p>The idea is to merge the elements into trees. <!-- Initially, we view each element as a tree with a single node. Recursively, if the root of tree $A$ is compared with and is less than the root of tree $B$, we make $A$ as a subtree of $B$.  --> Intuitively, the trees "remember" the comparison performed before and save us from comparing the same pairs again.</p>
<p>Various tree structure can be used to record the comparison and this may result in the design of different data structure. The one picked by Quake heap is the tournament tree. It only compares and merges (linking) two trees of the same height. A new node is created as the root of the two trees. The new node's value equals to the smaller one of the roots of the two trees.</p>
<p>For example, in the following example, both the node 4 and 5 are viewed as trees with height one. We can compare and link the two trees. A new node with value 4 (the smaller value between 4 and 5) is created as the new root of the merged tree.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2.jpg" /></p>
<p>We can continue to link node 3 and 2.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3.jpg" /></p>
<p>The linking is performed recursively. Noting the the current two trees have the same height, we link them. We need to also update the "min-pointer" during the linking.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4.jpg" /></p>
<p>The construction takes <span class="math inline">\(O(n)\)</span> time. But we can charge the cost of these link operations into the creation of the trees' roots before. We have performed 3 link operations for the four nodes each being the root of a singleton tree. On average, we pay <span class="math inline">\(O(1)\)</span> per operation. To make the amortized argument more vivid, we can think that conceptually we an additional coin for each singleton tree creation. Therefore, before linking, we have four coins as follows:</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-1-Coin.jpg" /></p>
<p>Merging node 5 and 4 has actual cost <span class="math inline">\(O(1)\)</span> and creates a new tree root. We use the coin of node 5 to pay the actual cost. Element 4 is the new root and it still has a coin. By using the coin idea, we charge (or averaging) the cost of this link operation to the cost of the creation of node 5.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-2-Coin.jpg" /></p>
<p>Merging node 3 and 2 uses one coin. We use the coin reserved by node 3. After this, the elements 4 and 2 (the elements that are roots of some trees) still have a coin.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-3-Coin.jpg" /></p>
<p>Merging the two trees left uses one coin. We use the coin reserved by node 4. After this, the element 2 is still a root and still has a coin.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-4-Coin.jpg" /></p>
<p>In general, we may need to pay more than <span class="math inline">\(O(1)\)</span> for delete-min(). Consider we would like to perform the operation for the following.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-5-Coin.jpg" /></p>
<p>We need to remove all nodes on a root-to-leaf path. In this example it is the path that contains element 2.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-6-Coin.jpg" /></p>
<p>After the removal, some children of the nodes in this root-to-leaf path are now exposed as tree roots. In this example, node 4 and 3 are tree roots. We need to reserve two coins node 4 and 3. The coins are reserved for potential linking performed in the future.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin1-7-Coin.jpg" /></p>
<p>Finally we need to compare and link any two trees of the same height, in a recursive manner. This part is paid by the coins reserved for the tree roots.</p>
<p>To analyze the amortized running time of delete-min(), we define the height of the tree as <span class="math inline">\(H\)</span>. We need to remove <span class="math inline">\(H\)</span> nodes from the root-to-leaf path, expose <span class="math inline">\(\max \{H - 1, 0 \}\)</span> node as tree roots and reserve coins for them, followed by recursively linking two trees with the same height. The final step is "free" and covered by the coins reserved. Therefore the amortized cost is <span class="math inline">\(H + \max \{H - 1, 0\} = \max \{ 2H - 1, H \} \le 2H\)</span>.</p>
<p><em>Key Observation:</em></p>
<blockquote>
<p><strong><em>To bound the time of delete-min() to <span class="math inline">\(O(\log n)\)</span>, it is critical to control the size of <span class="math inline">\(H\)</span>.</em></strong></p>
</blockquote>
<p>To analyze how large <span class="math inline">\(H\)</span> could be, we study how it grow. Initially, a tree with <span class="math inline">\(H = 1\)</span> contains only 1 key. When we link two trees with <span class="math inline">\(H = 1\)</span>, the new tree has height <span class="math inline">\(H = 2\)</span> and <span class="math inline">\(2\)</span> keys (although it has <span class="math inline">\(3\)</span> nodes). In general, a tree with height <span class="math inline">\(H = h\)</span> contains <span class="math inline">\(2^{h - 1}\)</span> keys and this can be easily proved by induction.</p>
<blockquote>
<p>If there is no decrease-key operation, the tree with height <span class="math inline">\(h\)</span> has <span class="math inline">\(2^{h - 1}\)</span> keys and <span class="math inline">\(2^h - 1\)</span> nodes. As there are at most <span class="math inline">\(n\)</span> keys, the maximum possible height, denoted as <span class="math inline">\(H\)</span>, is bounded by <span class="math inline">\(\log n\)</span>.</p>
</blockquote>
<p>The heap we have constructed so far has a special name called "Binomial Heap".</p>
<h3 id="decrease-key">Decrease-Key</h3>
<p>If there is only insert() and decrease-key() operation, min heap is easy to implemented. We can use a linked list / dynamic array, while maintaining the min pointer / min index.</p>
<p>If we need to incorporate delete-min() operation, the decrease-key(x) itself is still easy, while the former requires significant modification. For decrease-key(x), we adopt a lazy strategy. If after decreasing, <span class="math inline">\(x\)</span>'s value is still smaller than its parent (or <span class="math inline">\(x\)</span> is the root of the tree and has no parent), then everything is fine. For example, if we decrease <span class="math inline">\(4\)</span> to <span class="math inline">\(3.5\)</span> (the node 4 has parent 2), then we do not need to modify the tree after the operation.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-1.jpg" alt="drawing" width="330" /></p>
<p>On the other hand, if we decrease 4 to 1, then its value is smaller than its parent 2.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg" /></p>
<p>We need to detach the highest node containing value 4 from its parent node (in the meanwhile we maintain the "min-pointer").</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg" /></p>
<p>The only concern with this operation is the height of a heap. In the previous, the tree on the right hand side has height <span class="math inline">\(3\)</span> but contains only two keys. For a tree with <span class="math inline">\(n\)</span> keys, it could happens that it height is <span class="math inline">\(\omega(\log n)\)</span>. Indeed, it could be as large as <span class="math inline">\(O(n)\)</span>. This will invalidate the strategy we propose in the last section, which requires the height to be <span class="math inline">\(O(\log n)\)</span>, to achieve the <span class="math inline">\(O(\log n)\)</span> amortized complexity for delete-min().</p>
<p>There are various ways to fix this, the idea of which will give rise to Pairing heap [<em>Pairing heap achieve <span class="math inline">\(O(\log n)\)</span> amortized bound for deletion but requires <span class="math inline">\(O(\log n)\)</span> amortized time for both insertion and decrease-key(x). Its design philosophy is closely related to Splay tree.</em>], Fibonacci heap, etc. Here we discuss about the solution of Quake heap.</p>
<p>First, Quake heap records the number of nodes at each height explicitly, denoted as <span class="math inline">\(n_1, n_2, ..., n_H\)</span>, where <span class="math inline">\(H\)</span> is the maximum possible height. Further, it specifies a parameter <span class="math inline">\(\alpha \in (0, 5, 1)\)</span> and maintains the invariant that <span class="math inline">\(n_{i + 1} \le \alpha \cdot n_i\)</span> for each <span class="math inline">\(i \ge 1\)</span>. This guarantees that <span class="math inline">\(H = O(\log n)\)</span>.</p>
<p>In the following discussion, we take <span class="math inline">\(\alpha = 0.75\)</span>.</p>
<p>Let's discuss how the maintain the invariant <span class="math inline">\(n_{i + 1} \le \alpha n_i\)</span> for all <span class="math inline">\(i \ge 1\)</span> for insert(x), decrease-key(x) and delete-min() operation.</p>
<ol type="1">
<li><p>For the operation insert(x), it create a singleton node at the bottom layer and increases <span class="math inline">\(n_1\)</span> by 1. If the invariant holds before insertion, it holds afterward.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeight.jpg" /></p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/RecordingHeightAndInsertion.jpg" /></p></li>
<li><p>For decrease, it will not change the number of nodes at each height. The following example shows the case where the children whose key is decreased is detached from its parent. <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-2.jpg" /></p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DecreaseKey-3.jpg" /></p></li>
<li><p>Delete-min is the most difficult part. To maintain the invariant, now delete-min() consists of four part:</p>
<ul>
<li>Delete the min key (and all nodes that contain the min key). As before, this step may expose some children of the deleted nodes as new tree roots.</li>
<li>Recursively link all trees of the same height. After linking, scan all trees to maintain the min pointer.</li>
<li>Quake: if there is a level <span class="math inline">\(i\)</span> such that <span class="math inline">\(n_{i + 1} &gt; \alpha n_i\)</span>, remove all nodes with level greater than <span class="math inline">\(i\)</span>.</li>
</ul></li>
</ol>
<p>It is left to analyze the running time step by step. We use a potential function for analysis. By previous section, the potential should contain the number of trees. Further, by the last step of delete-min operation, it is suggested to includes the number of nodes in the potential function, to cover the cost of node removal. Inspired by this, our first design is given by <span class="math display">\[
\Phi = \# \text{nodes} + 2 \cdot \# \text{trees}
\]</span></p>
<p>We analyze the time for each step of delete-min()</p>
<ol type="1">
<li><p>Before delete-min(), the invariant holds and therefore the maximum height <span class="math inline">\(H = O(\log n)\)</span>. Deleting the min-key and its associated nodes take actual time <span class="math inline">\(O(\log n)\)</span>. As for <span class="math inline">\(\Phi\)</span>, the number of nodes decreases (indeed, this decrease will cover the removal of the nodes containing the min key) and the number of trees increases by at most <span class="math inline">\(O(\log n)\)</span>. Therefore, the amortized cost for the first step is <span class="math inline">\(O(\log n)\)</span>.</p></li>
<li><p>Linking two trees of the same height has actual cost <span class="math inline">\(1\)</span>. It creates a new node and decreases the number of trees by 1. Therefore, <span class="math inline">\(\Delta \Phi = -1\)</span>. Hence the amortized cost is 0. This also explains why we need an coefficient 2 associated with #trees in the potential function. It is left to analyze the cost of scanning all tree. After linking, all trees are of different height. It suffices to show that the maximum height is <span class="math inline">\(O(\log n)\)</span> to bound the scanning cost to <span class="math inline">\(O(\log n)\)</span>. Before linking <span class="math inline">\(H = O(\log n)\)</span>. As there are only <span class="math inline">\(n\)</span> keys, there are at most <span class="math inline">\(n\)</span> trees with height <span class="math inline">\(H\)</span> before and during the linking procedure. Linking <span class="math inline">\(n\)</span> trees of the same height results in a new tree with height <span class="math inline">\(\log n\)</span>. Therefore, after linking, <span class="math inline">\(H\)</span> increases by at most <span class="math inline">\(\log n\)</span> and <span class="math inline">\(H = O(\log n)\)</span> still holds. Therefore, the amortized cost for the second step is <span class="math inline">\(O(\log n)\)</span>.</p></li>
<li><p>Suppose in this step we delete <span class="math inline">\(k\)</span> nodes. The actual cost is <span class="math inline">\(k\)</span>. However, the number of nodes decreases by <span class="math inline">\(k\)</span>. It seems that the amortized cost is 0 for this step. But it isn't. We have increased the number of tree. Denote <span class="math inline">\(d_{i + 1}\)</span> the number of nodes at level <span class="math inline">\(i + 1\)</span> with two children before removal and <span class="math inline">\(s_{i + 1}\)</span> the number of nodes with only one children. We have <span class="math inline">\(n_{i + 1} = d_{i + 1} + s_{i + 1}\)</span>. On the other hand, we know <span class="math inline">\(n_i \ge 2 d_{i + 1} + s_{i + 1}\)</span>. By the fact that <span class="math inline">\(n_{i + 1} &gt; \alpha n_i\)</span>, we know that <span class="math display">\[
 \begin{aligned}
 s_{i + 1} 
     &amp;= 2(d_{i + 1} + s_{i + 1}) - (2 d_{i + 1} + s_{i + 1})\\
     &amp;\ge 2 n_{i + 1} - n_i \\
     &amp;\ge (2 \alpha - 1) n_i 
 \end{aligned}
 \]</span></p>
<p>as we create at most <span class="math inline">\(n_i\)</span> new trees, we can charge the creation of new trees into <span class="math inline">\(s_{i + 1}\)</span> and modify the potential as <span class="math display">\[
 \Phi = \# \text{nodes} + 2 \cdot \# \text{trees} + \frac{2}{2\alpha - 1} \# \text{nodes with one child}
 \]</span></p>
<p>Now step 3 has amortized cost 0. For other steps, this modification will increase the cost of decrease-key(x) by at most <span class="math inline">\(O(1)\)</span>.</p>
<p><img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-1.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-2.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-3.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-4.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-5.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-6.jpg" /> <img src="https://github.com/wuhao-wu-jiang/BlogImgs/raw/master/QuakeHeap/DeleteMin2-7.jpg" /></p></li>
</ol>
<p>Caveat: we can't swap the order of step 2 and step 3, since linking tree may create violation to the invariant and we need step 3 to fix this.</p>
<h3 id="reference">Reference</h3>
<p>[1] Chan, Timothy M. "Quake heaps: a simple alternative to Fibonacci heaps." In Space-Efficient Data Structures, Streams, and Algorithms, pp. 27-32. Springer, Berlin, Heidelberg, 2013.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/01/Ball%20and%20Bins/" rel="prev" title="Ball and Bins">
      <i class="fa fa-chevron-left"></i> Ball and Bins
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/11/k-Core-Decomposition/" rel="next" title="k-Core Decomposition">
      k-Core Decomposition <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#insertion"><span class="nav-number">1.</span> <span class="nav-text">Insertion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deletion-and-binomial-heap"><span class="nav-number">2.</span> <span class="nav-text">Deletion and Binomial Heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decrease-key"><span class="nav-number">3.</span> <span class="nav-text">Decrease-Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reference"><span class="nav-number">4.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WOW</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
