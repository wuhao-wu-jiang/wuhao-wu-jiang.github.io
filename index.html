<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="WOW">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="WOW">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WOW">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>WOW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WOW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">你生之前悠悠千載已逝<br>未來還會有千年沉寂的期待</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/Advanced-Joint-Convexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/Advanced-Joint-Convexity/" class="post-title-link" itemprop="url">Advanced Joint Convexity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-30 16:49:31 / Modified: 23:35:41" itemprop="dateCreated datePublished" datetime="2022-04-30T16:49:31+10:00">2022-04-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Let <span class="math inline">\((\Omega, \mathcal{F})\)</span> be a measurable space.</p>
<h1 id="alpha-divergence"><span class="math inline">\(\alpha\)</span>-Divergence</h1>
<blockquote>
<p><strong>Definition.</strong> Given <span class="math inline">\(\alpha \ge 1\)</span>, measures <span class="math inline">\(\mu, \nu\)</span> on <span class="math inline">\((\Omega, \mathcal{F})\)</span>, define the <span class="math inline">\(\alpha\)</span>-divergence from <span class="math inline">\(\mu\)</span> to <span class="math inline">\(\nu\)</span> by <span class="math display">\[
D_\alpha (\mu \Vert \nu) \doteq \sup_{S \in \mathcal{F}} \Big( \mu(S) - \alpha \cdot \nu(S) \Big). 
\]</span></p>
</blockquote>
<p>When <span class="math inline">\(\alpha = 1\)</span>, <span class="math inline">\(D_\alpha (\mu \Vert \nu)\)</span> is the <em>total variational distance</em> between <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span>.</p>
<h1 id="properties">Properties</h1>
<blockquote>
<p><strong>Theorem.</strong> <span class="math inline">\(D_\alpha (\mu \Vert \nu)\)</span> is non-negative.</p>
</blockquote>
<p><strong>Proof.</strong> Since <span class="math inline">\(\emptyset \in \mathcal{F}\)</span>, <span class="math display">\[
    D_\alpha (\mu \Vert \nu) \ge \mu(\emptyset) - \alpha \cdot \nu(\emptyset) = 0. 
\]</span> <span class="math inline">\(\square\)</span></p>
<blockquote>
<p><strong>Theorem (Joint Convexity).</strong> Let <span class="math inline">\(\mu, \nu, \mu&#39;, \nu&#39;\)</span> be measures on <span class="math inline">\((\Omega, \mathcal{F})\)</span>. For each <span class="math inline">\(\alpha \ge 1\)</span>, and <span class="math inline">\(t \in [0, 1]\)</span>, it holds that <span class="math display">\[
D_\alpha \left( (1 - t) \cdot  \mu + t \cdot \nu \Big\Vert t \cdot \mu&#39; + (1 - t) \cdot  \nu&#39; \right) 
\le 
(1 - t) \cdot  D_\alpha \big(  \mu \Vert \mu&#39; \big)
+
t \cdot D_\alpha \big( \nu \Vert \nu&#39; \big).
\]</span></p>
</blockquote>
<p><strong>Proof.</strong> <span class="math display">\[
    \begin{aligned}
        &amp;D_\alpha \left( (1 - t) \cdot  \mu + t \cdot \nu \Big\Vert t \cdot \mu&#39; + (1 - t) \cdot  \nu&#39; \right) \\
        = 
        &amp;\sup_{S \in \mathcal{F}} \Big( 
            (1 - t) \cdot  \mu(S) + t \cdot \nu(S) 
            - 
            \alpha \Big( 
                (1 - t) \cdot  \mu&#39;(S) + t \cdot \nu&#39;(S) 
            \Big)
        \Big) \\
        =
        &amp;\sup_{S \in \mathcal{F}} \Big( 
            (1 - t) \cdot  \Big( \mu(S) - \alpha \mu&#39;(S) \Big)
            +
            t \cdot \Big( \nu(S) - \alpha \nu&#39;(S) \Big)
        \Big) \\
        \le 
        &amp;\sup_{S \in \mathcal{F}} \Big( 
            (1 - t) \cdot  \Big( \mu(S) - \alpha \mu&#39;(S) \Big)
        \Big)
        +
        \sup_{S \in \mathcal{F}} \Big( 
            t \cdot \Big( \nu(S) - \alpha \nu&#39;(S) \Big)
        \Big) \\
        = 
        &amp; (1 - t) \cdot  D_\alpha (  \mu \Vert \mu&#39; )
        +
        t \cdot D_\alpha ( \nu \Vert \nu&#39; ).
    \end{aligned}
\]</span><br />
<span class="math inline">\(\square\)</span></p>
<blockquote>
<p><strong>Theorem (Advanced Joint Convexity [1]).</strong> Let <span class="math inline">\(\mu, \mu&#39;\)</span> be probability measures satisfying <span class="math display">\[
  \mu = (1 - t) \cdot  \mu_0 + t \cdot \mu_1, \quad \mu&#39; = (1 - t) \cdot  \mu_0 + t \cdot \mu_1&#39;,  
\]</span> for some <span class="math inline">\(t \in [0, 1]\)</span> and probability measures <span class="math inline">\(\mu_0, \mu_1, \mu_1&#39;\)</span>. Given <span class="math inline">\(\alpha \ge 1\)</span>, let <span class="math inline">\(\alpha&#39; = 1 + t \cdot (\alpha - 1)\)</span> and <span class="math inline">\(r = \alpha&#39; / \alpha\)</span>. Then the following holds: <span class="math display">\[
  D_{\alpha&#39;} ( \mu \Vert \mu&#39; ) = t \cdot D_\alpha ( \mu_1 \Vert (1 − r) \mu_0 + r \mu_{1}&#39;)
\]</span></p>
</blockquote>
<p><strong>Proof.</strong> For each <span class="math inline">\(S \in \mathcal{F}\)</span>, we have <span class="math display">\[
    \begin{aligned}
        \mu(S) - \alpha&#39; \mu&#39;(S) 
            &amp;= (1 - t) \cdot  \mu_0 (S) + t \cdot \mu_1 (S) -  \alpha&#39; (1 - t) \cdot  \mu_0 (S) - \alpha&#39; t \cdot \mu_1&#39;(S) \\
            &amp;=  t \cdot \left( \mu_1 (S)  - \alpha&#39; \mu_1&#39;(S) \right) - (1 - t) \cdot  \left( \alpha&#39; - 1  \right) \mu_0 (S) \\
            &amp;=  t \cdot \left( \mu_1 (S)  - \alpha \left( \frac{\alpha&#39;}{\alpha} \mu_1&#39;(S)  +  \frac{(1 - t) \cdot (\alpha&#39; - 1)}{t\alpha} \mu_0 (S) \right) \right)
    \end{aligned}
\]</span></p>
<p>The following conditions are equivalent <span class="math display">\[
    \begin{array}{lrl}
        &amp;1 - \alpha&#39; / \alpha &amp;= (1 - t) \cdot (\alpha&#39; - 1) / (t \cdot \alpha), \\
        \Longleftrightarrow\,
        &amp;t \cdot \alpha - t \cdot \alpha&#39; &amp;= \alpha&#39; - t \cdot \alpha&#39; - 1 + t, \\
        \Longleftrightarrow\, 
        &amp;1 + t \cdot (\alpha - 1) &amp;= \alpha&#39;. 
    \end{array}
\]</span></p>
<p>Therefore, assuming that <span class="math inline">\(1 + t(\alpha - 1) = \alpha&#39;\)</span> holds, and replacing <span class="math inline">\(\alpha&#39; / \alpha\)</span> with <span class="math inline">\(r\)</span>, we have <span class="math display">\[
    \mu(S) - \alpha&#39; \mu&#39;(S) = t \cdot \left( \mu_1 (S)  - \alpha \left( r \mu_1&#39;(S)  +  \big( 1 - r \big) \mu_0 (S) \right) \right), \quad 
    \forall S \in \mathcal{F}. 
\]</span></p>
<p>Tanking supremum over both hand sides finishes the proof.</p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="application">Application</h1>
<blockquote>
<p><strong>Definition.</strong> Let <span class="math inline">\(\mu, \nu\)</span> be measures on <span class="math inline">\((\Omega, \mathcal{F})\)</span>. Given <span class="math inline">\(\epsilon, \delta \ge 0\)</span>, <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\nu\)</span> are <span class="math inline">\((\epsilon , \delta)\)</span>-close, if <span class="math display">\[
D_{e^\epsilon} (\mu \Vert \nu) \le \delta, 
\qquad 
D_{e^\epsilon} (\nu \Vert \mu) \le \delta. 
\]</span></p>
</blockquote>
<p>Based on advanced joint convexity, we have the following result.</p>
<blockquote>
<p><strong>Corollary.</strong> Let <span class="math inline">\(\mu, \mu&#39;\)</span> be probability measures satisfying <span class="math display">\[
  \mu = (1 - t) \cdot  \mu_0 + t \cdot \mu_1, \quad \mu&#39; = (1 - t) \cdot  \mu_0 + t \cdot \mu_1&#39;,  
\]</span> for some <span class="math inline">\(t \in [0, 1]\)</span> and probability measures <span class="math inline">\(\mu_0, \mu_1, \mu_1&#39;\)</span>. Given <span class="math inline">\(\epsilon \ge 0\)</span>, let <span class="math inline">\(\epsilon&#39; = \ln \left(1 + t \cdot (e^\epsilon - 1) \right)\)</span> and <span class="math inline">\(r = e^{\epsilon&#39;} / e^{\epsilon}\)</span>. Combined with joint convexity, the following holds: <span class="math display">\[
\begin{aligned}
D_{e^{\epsilon&#39;}} ( \mu \Vert \mu&#39; ) 
&amp;= t \cdot D_{e^{\epsilon}} ( \mu_1 \Vert (1 − r) \mu_0 + r \mu_{1}&#39;)  \\
&amp;\le t \cdot \Big( (1 − r) \cdot D_{e^{\epsilon}} ( \mu_1 \Vert \mu_0 ) + r \cdot D_{e^{\epsilon}} ( \mu_1 \Vert \mu_{1}&#39;) \Big) \\
&amp;\le t \cdot \max \Big( D_{e^{\epsilon}} ( \mu_1 \Vert \mu_0 ), \, D_{e^{\epsilon}} ( \mu_1 \Vert \mu_{1}&#39;) \Big). 
\end{aligned}
\]</span></p>
</blockquote>
<p>Based on this corollary, suppose we know that <span class="math inline">\(\mu_0\)</span> and <span class="math inline">\(\mu_1\)</span> are <span class="math inline">\((\epsilon, \delta)\)</span>-close, and that <span class="math inline">\(\mu_1\)</span> and <span class="math inline">\(\mu_1&#39;\)</span> are <span class="math inline">\((\epsilon, \delta)\)</span>-close, then <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\mu&#39;\)</span> are <span class="math inline">\((\epsilon&#39;, t \delta)\)</span> close. If <span class="math inline">\(\epsilon \le 1\)</span>, then <span class="math display">\[
    \begin{array}{l}
        &amp;e^{\epsilon&#39;} = 1 + t \cdot (e^\epsilon - 1) \\
        \Longleftrightarrow
        &amp;e^{\epsilon&#39;} - 1 = t \cdot (e^\epsilon - 1) \\
        \Longleftrightarrow
        &amp;\epsilon&#39; \approx t \cdot \epsilon. 
    \end{array}
\]</span></p>
<p>In comparison, if we apply the joint convexity directly, we only get <span class="math display">\[
    D_{e^{\epsilon}} ( \mu \Vert \mu&#39; ) =
    t \cdot D_{e^{\epsilon}} ( \mu_1 \Vert \mu_1&#39; ), 
\]</span> and conclude that <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\mu&#39;\)</span> are <span class="math inline">\((\epsilon, t \delta)\)</span>-close. There is no amplification of <span class="math inline">\(\epsilon\)</span>.</p>
<h1 id="reference">Reference</h1>
<p>[1] <em>B. Balle, G. Barthe, and M. Gaboardi, “Privacy Amplification by Subsampling: Tight Analyses via Couplings and Divergences,” arXiv:1807.01647 [cs, stat], Nov. 2018, Accessed: Apr. 29, 2022. [Online]. Available: http://arxiv.org/abs/1807.01647</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/28/k-Center/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/28/k-Center/" class="post-title-link" itemprop="url">k-Center</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-28 22:35:10 / Modified: 23:47:59" itemprop="dateCreated datePublished" datetime="2022-04-28T22:35:10+10:00">2022-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="problem">Problem</h1>
<p>Let <span class="math inline">\(G = \langle V, E \rangle\)</span> be an undirected and complete graph, with a distance <span class="math inline">\(d(v, u) \in \mathbb{R}^+\)</span> between each pair of <span class="math inline">\(v, u \in V\)</span>. Assume that</p>
<ul>
<li><span class="math inline">\(d(v, v) = 0\)</span> for each <span class="math inline">\(v \in V\)</span>;</li>
<li><span class="math inline">\(d(v, u) = d(u, v)\)</span> for each <span class="math inline">\(v, u \in V\)</span>;</li>
<li>The distances satisfy triangle inequality: <span class="math display">\[
  d(v, w) \le d(v, u) + d(u, w), \qquad \forall v, u, w \in V. 
\]</span></li>
</ul>
<p>The goal is to find a set <span class="math inline">\(S \subset V\)</span> with size <span class="math inline">\(|S| = k\)</span>, for given input parameter <span class="math inline">\(k \in \mathbb{N}\)</span>, to minimize <span class="math display">\[
    \max_{v \in V} d(v, S), 
\]</span> where <span class="math inline">\(d(v, S) \doteq \min_{j \in S} d(v, u)\)</span> is the distance between <span class="math inline">\(i\)</span> and its nearest point in <span class="math inline">\(S\)</span>.</p>
<h1 id="approximation-algorithm">Approximation Algorithm</h1>
<blockquote>
<p><strong>Algorithm <span class="math inline">\(\mathcal{A}\)</span></strong><br />
1. Pick arbitrary point <span class="math inline">\(v_1\)</span> from <span class="math inline">\(V\)</span><br />
2. <span class="math inline">\(S \leftarrow \{ v_1 \}\)</span><br />
2. For <span class="math inline">\(t \leftarrow 2\)</span> to <span class="math inline">\(k\)</span> do<br />
3. <span class="math inline">\(\qquad\)</span> let <span class="math inline">\(v_t \doteq \underset{v \in V}{\arg \max} \, d(v, S)\)</span><br />
4. <span class="math inline">\(\qquad\)</span> <span class="math inline">\(S \leftarrow S \cup \{ v_t \}\)</span></p>
</blockquote>
<p>Denote the optimal solution as <span class="math inline">\(S^* \doteq \{ v_1^*, \ldots, v_k^* \}\)</span>: <span class="math display">\[
    S^* \doteq \underset{S \subseteq V, |S| = k}{\arg \min} \, \, \left( \max_{v \in V} d(v, S) \right). 
\]</span> We claim that the algorithm outputs a <span class="math inline">\(2\)</span>-approximate solution to <span class="math inline">\(S^*\)</span>.</p>
<blockquote>
<p><strong>Theorem.</strong> Algorithm <span class="math inline">\(\mathcal{A}\)</span> outputs a <span class="math inline">\(2\)</span>-approximate solution: <span class="math display">\[
\max_{v \in V} d(v, S) \le 2 \cdot \max_{v \in V} d(v, S^*). 
\]</span></p>
</blockquote>
<p><strong>Proof.</strong> We can partition the vertices in <span class="math inline">\(V\)</span> into <span class="math inline">\(k\)</span> subsets <span class="math inline">\(V_1^*, \ldots V_k^*\)</span>, such that <span class="math display">\[
    V_i^* \doteq \left\{ v \in V: \underset{v^* \in S^*}{\arg \min} \, d(v, v^*)  = v_i^* \right\}, \qquad \forall i \in [k]. 
\]</span></p>
<blockquote>
<p><strong>Lemma.</strong> If <span class="math inline">\(u, w\)</span> belongs to the same subset <span class="math inline">\(V_i^*\)</span>, then <span class="math display">\[
d(u, w) 
\le 
d(u, v_i^*) + d(v_i^*, w) 
\le 
2 \cdot \max_{v \in V} d(v, S^*). 
\]</span></p>
</blockquote>
<p>We consider the following two cases:</p>
<p><strong>Case One.</strong> For each <span class="math inline">\(i \in [k]\)</span>, <span class="math inline">\(|V_i^* \cap S| = 1\)</span>. Fix an <span class="math inline">\(i \in [k]\)</span>, and let <span class="math inline">\(v_t \in V_i^* \cap S\)</span>. Then for each <span class="math inline">\(u \in V_i^*\)</span>, via the lemma, <span class="math display">\[
    d(u, S) \le d(u, v_t) 
    \le 
    2 \cdot \max_{v \in V} d(v, S^*). 
\]</span> Since <span class="math inline">\(V_i^*, i \in [k]\)</span> is a partition of <span class="math inline">\(V\)</span>, this holds for all <span class="math inline">\(u \in V\)</span>.</p>
<p><strong>Case Two.</strong> There exists some <span class="math inline">\(V_i^*\)</span> contains more than one points in <span class="math inline">\(S\)</span>. This implies that at some iteration, the algorithm <span class="math inline">\(\mathcal{A}\)</span> selects a point <span class="math inline">\(v_t \in V_i^*\)</span>, even though it has selected a point <span class="math inline">\(v_t&#39; \in V_i^*\)</span> in an earlier iteration.</p>
<p>When <span class="math inline">\(v_t\)</span> is selected, via the lemma, it holds that <span class="math display">\[
    d(v_t, S) \le d(v_t, v_t&#39;) \le 2 \cdot \max_{v \in V} d(v, S^*). 
\]</span></p>
<p>Since <span class="math inline">\(v_t\)</span> is the farthest point from <span class="math inline">\(S\)</span> when it is selected, all points are within a distance of <span class="math inline">\(2 \cdot \max_{v \in V} d(v, S^*)\)</span> from <span class="math inline">\(S\)</span>. This remains true as the algorithm <span class="math inline">\(\mathcal{A}\)</span> adds more points.</p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="reference">Reference</h1>
<p>[1] <em>D. P. Williamson and D. B. Shmoys, The Design of Approximation Algorithms. Cambridge: Cambridge University Press, 2011.</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/21/Set-Cover/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WOW">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WOW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/21/Set-Cover/" class="post-title-link" itemprop="url">Set Cover</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-21 17:31:38" itemprop="dateCreated datePublished" datetime="2022-04-21T17:31:38+10:00">2022-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-22 15:28:59" itemprop="dateModified" datetime="2022-04-22T15:28:59+10:00">2022-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="set-cover-problem">Set Cover Problem</h1>
<p>Let <span class="math inline">\(\Omega = \{ a_1, \ldots, a_n \}\)</span> be a set, and <span class="math inline">\(S_1, \ldots, S_m\)</span> be subsets of <span class="math inline">\(\Omega\)</span>, such that <span class="math inline">\(S_j\)</span> is associated with weight <span class="math inline">\(w_j \in \mathbb{R}^+\)</span> for each <span class="math inline">\(j \in [m]\)</span>. The goal is solve the following the following optimization problem <span class="math display">\[
    \begin{array}{lll}
        &amp;\min_{J \subseteq [m]} &amp;\sum_{j \in J} w_j, \\
        &amp;\text{s.t.}          &amp;\cup_{j \in J} S_j = \Omega  
    \end{array}
\]</span> In case where <span class="math inline">\(w_j = 1\)</span> for each <span class="math inline">\(j \in [m]\)</span>, the problem is called the <em>unweighted</em> set cover problem.</p>
<h1 id="linear-programming">Linear Programming</h1>
<p>The linear program for the problem is <span class="math display">\[
    \begin{array}{llr}
        \min                &amp;\sum_{j \in [m]} w_j \cdot x_j    \\
        \text{s.t.}         &amp;\sum_{j : a_i \in S_j} x_j \ge 1     &amp;\forall i \in [n]\\
                            &amp;x_j \ge 0                      &amp;\forall j \in [m]
    \end{array}
\]</span></p>
<p>The dual LP of the primal is <span class="math display">\[
    \begin{array}{llr}
        \max                &amp;\sum_{i \in [n]} y_i    \\
        \text{s.t.}         &amp;\sum_{i: a_i \in S_j} y_i \le w_j     &amp;\forall j \in [m]\\
                            &amp;y_i \ge 0                      &amp;\forall i \in [n]
    \end{array}
\]</span></p>
<h1 id="rounding-the-optimal-primal-solution">Rounding the Optimal Primal Solution</h1>
<p>For each element <span class="math inline">\(i \in [n]\)</span>, let <span class="math inline">\(E_i \doteq \{ j \in [m] : a_i \in S_j \}\)</span>, and let <span class="math inline">\(C = \max_{i \in [n]} |E_i|\)</span>.</p>
<p>Suppose that <span class="math inline">\(x_j^*, j \in [m]\)</span> be the optimal solution to the primal LP.</p>
<blockquote>
<p><strong>Theorem.</strong> <span class="math display">\[
J \doteq \left\{ j \in [m] : x_j^* \ge \frac{1}{C} \right\}
\]</span> is a <span class="math inline">\(C\)</span>-approximate solution to the set cover problem.</p>
</blockquote>
<p><strong>Proof.</strong> We prove first that <span class="math inline">\(S_j, j \in J\)</span> is a set cover, then we prove that it is a <span class="math inline">\(C\)</span> approximate one.</p>
<p><strong>Feasibility.</strong> Since <span class="math inline">\(x_j^*\)</span> is the optimal solution to the primal LP, for each <span class="math inline">\(i \in [n]\)</span>, we have <span class="math display">\[
    \sum_{j : a_i \in S_j} x_j \ge 1.
\]</span> Therefore, , there exists at least one <span class="math inline">\(j \in E_i\)</span>, s.t., <span class="math display">\[
    x_j^* \ge \frac{1}{|E_i|} \ge \frac{1}{C}. 
\]</span></p>
<p><strong>Approximation Ratio.</strong> The cost of the approximate solution is given by <span class="math display">\[
    \sum_{j \in J} w_j 
            \le \sum_{j \in J} w_j \cdot \big( x_j^* \cdot C \big) 
            \le C \cdot \sum_{j \in [m]} w_j \cdot x_j^*.
\]</span></p>
<p><span class="math inline">\(\square\)</span></p>
<p><strong>Remark.</strong> This is a <span class="math inline">\(2\)</span>-approximation algorithm for the vertex cover problem, a special case of the set cover problem.</p>
<h1 id="rounding-the-optimal-dual-solution">Rounding the Optimal Dual Solution</h1>
<p>Let <span class="math inline">\(y_i^*, i \in [n]\)</span> be the optimal solution to the dual.</p>
<blockquote>
<p><strong>Theorem.</strong> <span class="math display">\[
J&#39; \doteq \left\{ j \in [m] : \sum_{i: a_i \in S_j} y^*_i = w_j \right\}
\]</span> is a <span class="math inline">\(C\)</span>-approximate solution to the set cover problem.</p>
</blockquote>
<p><strong>Proof.</strong> We prove first that <span class="math inline">\(S_j, j \in J&#39;\)</span> is a set cover, then we prove that it is a <span class="math inline">\(C\)</span> approximate one.</p>
<p><strong>Feasibility.</strong> Suppose that there exits an uncovered element <span class="math inline">\(a_k\)</span>, which implies that for each <span class="math inline">\(j \in E_k\)</span>, it holds that <span class="math display">\[
    \sum_{i: a_i \in S_j} y^*_i &lt; w_j. 
\]</span> But this implies that we can increase the value of <span class="math inline">\(y_k^*\)</span>, and therefore increase the value of <span class="math inline">\(\sum_{i \in [n]} y_i^*\)</span>, without violating the dual constraints, contradicting the <span class="math inline">\(y_i^*, i \in [n]\)</span> being optimal.</p>
<p><strong>Approximation Ratio.</strong> The cost of the approximate solution is given by <span class="math display">\[
    \sum_{j \in J&#39;} w_j 
            = \sum_{j \in J&#39;} \left( \sum_{i: a_i \in S_j} y^*_i \right) 
            \le \sum_{i \in [n]} \left( \sum_{i: a_i \in S_j} y^*_i \right) 
            \le C \cdot \sum_{i \in [n]} y^*_i, 
\]</span> where the last inequality holds, since each <span class="math inline">\(y_i^*\)</span> appears in at most <span class="math inline">\(C\)</span> constraints.</p>
<p><span class="math inline">\(\square\)</span></p>
<p><strong>Remark.</strong> Via <em>complementary slackness</em>, if <span class="math inline">\(x_j^* &gt; 0\)</span>, we always have <span class="math display">\[
    \sum_{i : a_i \in S_j} y^*_i = w_j. 
\]</span> Since <span class="math inline">\(J \doteq \left\{ j \in [m] : x_j^* \ge 1 / C \right\}\)</span>, it holds that <span class="math inline">\(J \subseteq J&#39;\)</span>. Therefore, rounding the primal solution do no worse than rounding the dual one.</p>
<h1 id="the-primal-dual-method">The Primal-Dual Method</h1>
<p>Rounding the optimal dual solution requires to solve the dual LP optimally, which could be slow even though the LP can be solved in polynomial time. The following algorithm overcomes this drawback by constructing only a feasible dual solution.</p>
<blockquote>
<p><strong>Algorithm.</strong> <strong><span class="math inline">\(\mathcal{A}_{primal \text{-} dual}\)</span></strong><br />
1. <span class="math inline">\(y_i \leftarrow 0\)</span>, for each <span class="math inline">\(i \in [n]\)</span><br />
2. <span class="math inline">\(J \leftarrow \emptyset\)</span><br />
3. <strong>while</strong> <span class="math inline">\(\exists a_k \notin \cup_{j \in J} S_j\)</span> <strong>do</strong><br />
4. <span class="math inline">\(\qquad\)</span> increase <span class="math inline">\(y_k\)</span> until some constraint becomes tight,<br />
6. <span class="math inline">\(\qquad\)</span> i.e., <span class="math inline">\(\exists S_\ell\)</span> with <span class="math inline">\(a_k \in S_j\)</span>, s.t., <span class="math inline">\(\sum_{i: a_i \in S_\ell} y_i = w_\ell\)</span><br />
7. <span class="math inline">\(\qquad\)</span> <span class="math inline">\(J \leftarrow J \cup \{ \ell \}\)</span></p>
</blockquote>
<p>Clearly the <span class="math inline">\(y_i, i \in [n]\)</span> is a feasible solution to the dual.</p>
<blockquote>
<p><strong>Theorem.</strong> Algorithm <span class="math inline">\(\mathcal{A}_{primal \text{-} dual}\)</span> returns a <span class="math inline">\(C\)</span>-approximate solution <span class="math inline">\(J\)</span> to the set cover problem.</p>
</blockquote>
<p><strong>Proof.</strong> We prove first that <span class="math inline">\(S_j, j \in J\)</span> is a set cover, then we prove that it is a <span class="math inline">\(C\)</span> approximate one.</p>
<p><strong>Feasibility.</strong> Suppose that there exits an element <span class="math inline">\(a_k\)</span> that is not covered by <span class="math inline">\(J\)</span>, which implies that for each <span class="math inline">\(j \in E_k\)</span>, it holds that <span class="math display">\[
    \sum_{i: a_i \in S_j} y_i &lt; w_j. 
\]</span> But this implies that we can increase the value of <span class="math inline">\(y_k\)</span>, and therefore increase the value of <span class="math inline">\(\sum_{i \in [n]} y_i\)</span>, without violating the dual constraints, contradicting <span class="math inline">\(y_i\)</span> being optimal.</p>
<p><strong>Approximation Ratio.</strong> The cost of the approximate solution is given by <span class="math display">\[
    \sum_{j \in J} w_j 
            = \sum_{j \in J} \left( \sum_{i: a_i \in S_j} y_i \right) 
            \le \sum_{i \in [n]} \left( \sum_{i: a_i \in S_j} y_i \right) 
            \le C \cdot \sum_{j \in [m]} y_i, 
\]</span> where the last inequality holds, since each <span class="math inline">\(y_i\)</span> appears in at most <span class="math inline">\(C\)</span> constraints.</p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="randomized-rounding">Randomized Rounding</h1>
<p>We present a randomized algorithm based on the optimal solution <span class="math inline">\(x_j^*\)</span> for the primal LP.</p>
<p>Let <span class="math inline">\(T \in \mathbb{N}^+\)</span> be a positive integer to be determined later.</p>
<blockquote>
<p><strong>Algorithm.</strong> <span class="math inline">\(\mathcal{A}_{rnd}\)</span><br />
1. <strong>for</strong> <span class="math inline">\(t \in [T]\)</span> <strong>do</strong><br />
2. <span class="math inline">\(\qquad\)</span> <span class="math inline">\(J_t \leftarrow \emptyset\)</span><br />
3. <span class="math inline">\(\qquad\)</span> <strong>for</strong> each <span class="math inline">\(j \in [m]\)</span> <strong>do</strong><br />
4. <span class="math inline">\(\qquad\)</span> <span class="math inline">\(\qquad\)</span> add <span class="math inline">\(j\)</span> to <span class="math inline">\(J_t\)</span> with probability <span class="math inline">\(x_j^*\)</span><br />
5. output <span class="math inline">\(J \leftarrow \cup_{t \in [T]} J_t\)</span></p>
</blockquote>
<blockquote>
<p><strong>Theorem.</strong> The expected cost of <span class="math inline">\(J\)</span> is at most <span class="math inline">\(T \cdot \sum_{j \in [m]} w_j \cdot x_j^*\)</span>. Further, if <span class="math inline">\(T = 2 \ln n\)</span>, with probability at least <span class="math inline">\(1 - 1 / n\)</span>, <span class="math inline">\(J\)</span> is a set cover.</p>
</blockquote>
<p><strong>Proof.</strong></p>
<p><strong>Expected Cost.</strong> Since <span class="math inline">\(j\)</span> is included in <span class="math inline">\(J_t\)</span> with probability <span class="math inline">\(x_j^*\)</span> for each <span class="math inline">\(j \in [m]\)</span>, by linearity of expectation, the expected sum of weights of sets in <span class="math inline">\(J_t\)</span> is given by <span class="math display">\[
    \sum_{j \in [m]} w_j \cdot x_j^*. 
\]</span> Therefore, the expected cost of <span class="math inline">\(J\)</span> is at most <span class="math inline">\(T \cdot \sum_{j \in [m]} w_j \cdot x_j^*\)</span>.</p>
<p><strong>Failure Probability.</strong> The probability that a fixed <span class="math inline">\(a_i\)</span> is not covered by <span class="math inline">\(J_t\)</span> is given by <span class="math display">\[
    \begin{aligned}
        \prod_{j : a_i \in S_j} (1 - x_j^*)
        \le \exp \left( - \sum_{j : a_i \in S_j} x_j^* \right)
        \le \exp (- 1). 
    \end{aligned}
\]</span> By independence, the probability that none of the <span class="math inline">\(J_t\)</span> covers <span class="math inline">\(a_i\)</span> is at most <span class="math display">\[
    \big( \exp(-1) \big)^T = \exp(-T) = 1 / n^2. 
\]</span> Applying union bound over all element <span class="math inline">\(a_i \in \Omega\)</span> finishes the proof.</p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="greedy-algorithm">Greedy Algorithm</h1>
<p>Finally, we discuss a greedy algorithm for the set cover problem.</p>
<p>We follows the convention that <span class="math inline">\(x / 0 = \infty\)</span>, <span class="math inline">\(\forall x \in \mathbb{R}^+\)</span>.</p>
<blockquote>
<p><strong>Algorithm.</strong> <span class="math inline">\(\mathcal{A}_{greedy}\)</span><br />
1. <span class="math inline">\(\hat S_j \leftarrow S_j\)</span>, for each <span class="math inline">\(j \in [m]\)</span><br />
2. <span class="math inline">\(J \leftarrow \emptyset\)</span><br />
3. <strong>while</strong> <span class="math inline">\(\cup_{j \in J} S_j \neq \Omega\)</span> <strong>do</strong><br />
4. <span class="math inline">\(\qquad\)</span> <span class="math inline">\(\ell \leftarrow \min_{j \in [m]} \left( w_j / |\hat S_j| \right)\)</span><br />
7. <span class="math inline">\(\qquad\)</span> <span class="math inline">\(J \leftarrow J \cup \{ \ell \}\)</span><br />
8. <span class="math inline">\(\qquad\)</span> <span class="math inline">\(\hat S_j \leftarrow \hat S_j \setminus S_\ell\)</span>, <span class="math inline">\(\forall j \in [m]\)</span></p>
</blockquote>
<p>For each <span class="math inline">\(k \in \mathbb{N}^+\)</span>, define <span class="math inline">\(H_k = \sum_{i \in [k]} 1 / i\)</span>.</p>
<blockquote>
<p><strong>Theorem.</strong> <span class="math inline">\(\mathcal{A}_{greedy}\)</span> outputs a <span class="math inline">\(H_n\)</span> approximate solution <span class="math inline">\(J\)</span> to the set cover problem.</p>
</blockquote>
<p><strong>Proof.</strong> When an <span class="math inline">\(\ell\)</span> is added to <span class="math inline">\(J\)</span>, it is easy to see that <span class="math inline">\(\hat S_\ell \neq \emptyset\)</span>, as otherwise <span class="math inline">\(w_\ell / |\hat S_\ell| = \infty\)</span>. Therefore we can charge the cost of <span class="math inline">\(w_\ell\)</span> among elements in <span class="math inline">\(\hat S_\ell\)</span>, with each elements <span class="math inline">\(a_i \in \hat S_\ell\)</span> obtaining a cost of<br />
<span class="math display">\[
    y_i \doteq w_\ell / |\hat S_\ell|. 
\]</span></p>
<p>Since each <span class="math inline">\(a_i \in \Omega\)</span> is charged exactly once, it holds that <span class="math display">\[
    \sum_{j \in J} w_j = \sum_{i \in [n]} y_i. 
\]</span></p>
<p>Our proof is based on the following lemma.</p>
<blockquote>
<p><strong>Lemma.</strong> For each <span class="math inline">\(j \in [m]\)</span>, it holds that <span class="math display">\[
\sum_{i : a_i \in S_j} y_i \le w_j \cdot H_{|S_j|}. 
\]</span></p>
</blockquote>
<p>We now finish the proof for the theorem, assuming the lemma holds. Let <span class="math inline">\(D \doteq \max_{j \in [m} |S_j| \le n\)</span>. For each <span class="math inline">\(i \in [n]\)</span>, define new variable <span class="math inline">\(\hat y_i = y_i / H_D\)</span>. Then the <span class="math inline">\(\hat y_i\)</span> is a feasible solution to the dual LP, and therefore <span class="math inline">\(\sum_{i \in [n]} \hat y_i \le \text{OPT}\)</span>, where <span class="math inline">\(\text{OPT}\)</span> is the value of the optimal solution to the set cover problem. We conclude that<br />
<span class="math display">\[
    \sum_{j \in J} w_j 
        = \sum_{i \in [n]} y_i 
        = H_D \cdot \sum_{i \in [n]} \hat y_i 
        \le H_D \cdot \text{OPT}. 
\]</span></p>
<p><em>Proof of the Lemma.</em> Suppose that the solution <span class="math inline">\(J\)</span> returned by <span class="math inline">\(\mathcal{A}_{greedy}\)</span> consists <span class="math inline">\(t\)</span> numbers <span class="math inline">\(\ell_1, \ldots, \ell_t\)</span>, indexed according to their orders added to <span class="math inline">\(J\)</span>.</p>
<p>For each <span class="math inline">\(k \in [t]\)</span>, define <span class="math display">\[
    r_k \doteq \Big| S_j \setminus \big( S_{\ell_1} \cup S_{\ell_2} \cup \ldots \cup S_{\ell_{k - 1}}) \Big|. 
\]</span></p>
<p>Note that <span class="math inline">\(r_k\)</span> is the number of new elements in <span class="math inline">\(S_j\)</span> that is covered by sets indexed by <span class="math inline">\(J\)</span>, before <span class="math inline">\(\ell_k\)</span> is added to <span class="math inline">\(J\)</span>. For convenience, let <span class="math inline">\(r_0 = n\)</span>. For each <span class="math inline">\(k \in [t]\)</span>, define <span class="math inline">\(c_k = r_k - r_{k - 1}\)</span>. We claim that for each <span class="math inline">\(k \in [t]\)</span>, it holds that <span class="math display">\[
    \sum_{i : a_i \in S_j \cap \hat S_{\ell_k}} y_i = c_k \cdot y_i \le c_k \cdot \frac{w_j}{r_k}. 
\]</span></p>
<p>If <span class="math inline">\(S_j \cap \hat S_{\ell_k} = \emptyset\)</span>, then <span class="math inline">\(c_k = 0\)</span> and the claim holds trivially. Otherwise, the criteria for picking <span class="math inline">\(\ell_k\)</span> by <span class="math inline">\(\mathcal{A}_{greedy}\)</span> ensures that for each <span class="math inline">\(a_i \in S_j \cap \hat S_{\ell_k}\)</span>, it holds that <span class="math display">\[
    y_i = \frac{w_{\ell_k} }{|\hat S_{\ell_k}|} \le \frac{w_j}{r_k}. 
\]</span></p>
<p>Therefore, <span class="math display">\[
    \begin{aligned}
        \sum_{i : a_i \in S_j} y_i 
            &amp;= \sum_{k \in [t]} \sum_{i : a_i \in S_j \cap \hat S_{\ell_k}} y_i \\
            &amp;\le \sum_{k \in [t]} c_k \cdot \frac{w_j}{r_k} \\
            &amp;\le \sum_{k \in [t]} w_j \left( \frac{1}{r_k} + \frac{1}{r_k - 1} + \ldots + \frac{1}{r_k - c_k + 1} \right) \\
            &amp;= w_j \sum_{k \in \big[ |S_j| \big]} \frac{1}{k} \\
            &amp;= w_j \cdot H_{|S_j|}. 
    \end{aligned}
\]</span></p>
<p><span class="math inline">\(\square\)</span></p>
<h1 id="reference">Reference</h1>
<p>[1] <em>D. P. Williamson and D. B. Shmoys, The Design of Approximation Algorithms. Cambridge: Cambridge University Press, 2011.</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/61/">61</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WOW</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">183</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WOW</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
